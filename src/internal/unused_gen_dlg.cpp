///////////////////////////////////////////////////////////////////////////////
// Code generated by wxUiEditor - see https://github.com/KeyWorksRW/wxUiEditor/
//
// Do not edit any code above the "End of generated code" comment block.
// Any changes before that block will be lost if it is re-generated!
///////////////////////////////////////////////////////////////////////////////

// clang-format off

#include <wx/button.h>
#include <wx/sizer.h>
#include <wx/stattext.h>

#include <unordered_set>

#include "unused_gen_dlg.h"

#include "gen_enums.h"
#include "node.h"
#include "project_handler.h"

auto UnusedGenerators::Create(wxWindow* parent, wxWindowID id, const wxString& title,
    const wxPoint& pos, const wxSize& size, long style, const wxString &name) -> bool
{
    // Scaling of pos and size are handled after the dialog
    // has been created and controls added.
    if (!wxDialog::Create(parent, id, title, pos, size, style, name))
    {
        return false;
    }

    auto* dlg_sizer = new wxBoxSizer(wxVERTICAL);

    auto* staticText = new wxStaticText(this, wxID_ANY, "Unused generators in the entire project");
    staticText->Wrap(200);
    dlg_sizer->Add(staticText, wxSizerFlags().Border(wxALL));

    m_listbox = new wxListBox(this, wxID_ANY);
    m_listbox->SetMinSize(FromDIP(wxSize(240, 250)));
    dlg_sizer->Add(m_listbox, wxSizerFlags().Expand().Border(wxALL));

    auto* btn = new wxButton(this, wxID_ANY, "&Save...");
    dlg_sizer->Add(btn, wxSizerFlags().Border(wxALL));

    auto* stdBtn = CreateStdDialogButtonSizer(wxOK);
    dlg_sizer->Add(CreateSeparatedSizer(stdBtn), wxSizerFlags().Expand().Border(wxALL));

    if (pos != wxDefaultPosition)
    {
        // Now that the dialog is created, set the scaled position
        SetPosition(FromDIP(pos));
    }
    if (size == wxDefaultSize)
    {
        // If default size let the sizer set the dialog's size
        // so that it is large enough to fit it's child controls.
        SetSizerAndFit(dlg_sizer);
    }
    else
    {
        SetSizer(dlg_sizer);
        if (size.x == wxDefaultCoord || size.y == wxDefaultCoord)
        {
            // Use the sizer to calculate the missing dimension
            Fit();
        }
        SetSize(FromDIP(size));
        Layout();
    }
    Centre(wxBOTH);

    // Event handlers
    btn->Bind(wxEVT_BUTTON, &UnusedGenerators::OnSave, this);
    Bind(wxEVT_INIT_DIALOG, &UnusedGenerators::OnInit, this);

    return true;
}

// ************* End of generated code ***********
// DO NOT EDIT THIS COMMENT BLOCK!
//
// Code below this comment block will be preserved
// if the code for this class is re-generated.
//
// clang-format on
// ***********************************************

/////////////////// Non-generated Copyright/License Info ////////////////////
// Author:    Ralph Walden
// Copyright: Copyright (c) 2023 KeyWorks Software (Ralph Walden)
// License:   Apache License -- see ../../LICENSE
/////////////////////////////////////////////////////////////////////////////

#include <wx/filedlg.h>

#include "wxue_namespace/wxue_string_vector.h"  // wxue::StringVector

void FindGenerators(Node* node,
                    std::unordered_set<std::string, str_view_hash, std::equal_to<>>& used)
{
    if (node->is_Gen(gen_Images) || node->is_Gen(gen_Data))
        return;
    if (!node->is_Gen(gen_folder) && !node->is_Gen(gen_sub_folder))
    {
        auto genNameIter = map_GenNames.find(node->get_GenName());
        if (genNameIter != map_GenNames.end() && !used.contains(genNameIter->second))
        {
            used.emplace(genNameIter->second);
        }
    }
    if (node->get_ChildCount())
    {
        for (auto& child: node->get_ChildNodePtrs())
        {
            FindGenerators(child.get(), used);
        }
    }
}

// clang-format off

const auto gen_ignore_list = {

    gen_VerticalBoxSizer,
    gen_gbsizeritem,
    gen_name_array_size,
    gen_oldbookpage,
    gen_sizer_dimension,
    gen_sizeritem,
    gen_splitteritem,

    // These are categories, not actual generators -- this should be kept in sync with the
    // categories in gen_enums.cpp

    gen_Bitmaps,
    gen_Boolean_Validator,
    gen_Choice_Validator,
    gen_Code,
    gen_Code_Generation,
    gen_Command_Bitmaps,
    gen_DlgWindowSettings,
    gen_Integer_Validator,
    gen_List_Validator,
    gen_String_Validator,
    gen_Text_Validator,
    gen_Window_Events,
    gen_XRC,
    gen_XrcSettings,
    gen_flexgridsizerbase,
    gen_folder_Code,
    gen_folder_XRC,
    gen_folder_wxPython,
    gen_folder_wxRuby,
    gen_sizer_child,
    gen_sizeritem_settings,
    gen_wxMdiWindow,
    gen_wxPython,
    gen_wxTopLevelWindow,
    gen_wxTreeCtrlBase,
    gen_wxWindow,

    gen_CPlusSettings,
    gen_DerivedCPlusSettings,
    gen_CPlusHeaderSettings,
    gen_PythonSettings,
    gen_RubySettings,

    gen_unknown,

};

// clang-format on

void UnusedGenerators::OnInit(wxInitDialogEvent& event)
{
    std::unordered_set<std::string, str_view_hash, std::equal_to<>> used;

    for (const auto& child: Project.get_ProjectNode()->get_ChildNodePtrs())
    {
        FindGenerators(child.get(), used);
    }

    bool skipping = true;
    for (auto& iter: rmap_GenNames)
    {
        bool ignored_gen = false;
        for (const auto& ignore: gen_ignore_list)
        {
            if (ignore == iter.second)
            {
                ignored_gen = true;
                break;
            }
        }
        if (ignored_gen)
        {
            continue;
        }

        if (skipping)
        {
            if (iter.second != gen_BookPage)
            {
                continue;
            }

            skipping = false;
        }

        if (!used.contains(iter.first))
        {
            m_listbox->Append(wxString::FromUTF8Unchecked(iter.first.data(), iter.first.size()));
        }
    }

    event.Skip();
}

void UnusedGenerators::OnSave(wxCommandEvent& /* event unused */)
{
    auto filename = wxSaveFileSelector("Save unused", "txt", wxEmptyString, this);
    if (filename.empty())
    {
        return;
    }

    wxue::StringVector file;
    for (unsigned int idx = 0; idx < m_listbox->GetCount(); ++idx)
    {
        file.emplace_back(m_listbox->GetString(idx).ToStdString());
    }

    if (auto result = file.WriteFile(filename.utf8_string()); !result)
    {
        wxMessageBox(wxString("Cannot create or write to the file ") << filename, "Save unused");
    }
}
