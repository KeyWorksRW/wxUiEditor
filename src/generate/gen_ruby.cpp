/////////////////////////////////////////////////////////////////////////////
// Purpose:   Generate Ruby code files
// Author:    Ralph Walden
// Copyright: Copyright (c) 2023-2024 KeyWorks Software (Ralph Walden)
// License:   Apache License -- see ../../LICENSE
/////////////////////////////////////////////////////////////////////////////

#include <wx/artprov.h>

#include <set>
#include <thread>
#include <unordered_set>

#include "mainframe.h"

#include "base_generator.h"   // BaseGenerator -- Base widget generator class
#include "code.h"             // Code -- Helper class for generating code
#include "dlg_msgs.h"         // wxMessageDialog dialogs
#include "file_codewriter.h"  // FileCodeWriter -- Classs to write code to disk
#include "gen_base.h"         // BaseCodeGenerator -- Generate Src and Hdr files for Base Class
#include "gen_common.h"       // Common component functions
#include "gen_results.h"      // Code generation file writing functions
#include "gen_timer.h"        // TimerGenerator class
#include "image_gen.h"        // Functions for generating embedded images
#include "image_handler.h"    // ImageHandler class
#include "node.h"             // Node class
#include "project_handler.h"  // ProjectHandler class
#include "utils.h"            // Miscellaneous utilities
#include "write_code.h"       // Write code to Scintilla or file

#include "pugixml.hpp"

using namespace code;
using namespace GenEnum;

// clang-format off

inline constexpr const auto txt_PoundCmtBlock =
R"===(###############################################################################
# Code generated by wxUiEditor -- see https://github.com/KeyWorksRW/wxUiEditor/
#
# Do not edit any code above the "End of generated code" comment block.
# Any changes before that block will be lost if it is re-generated!
###############################################################################

)===";

inline constexpr const auto txt_ruby_get_bundle =
R"===(
# Loads image(s) from a string and returns a Wx::BitmapBundle object.
def wxue_get_bundle(image_name1, image_name2 = nil, image_name3 = nil)
  image1 = Wx::Image.new
  image1.load_stream(StringIO.new(image_name1))
  if (image_name2)
    image2 = Wx::Image.new
    image2.load_stream(StringIO.new(image_name2))
    if (image_name3)
      image3 = Wx::Image.new
      image3.load_stream(StringIO.new(image_name3))
      bitmaps = [Wx::Bitmap.new(image1),
                 Wx::Bitmap.new(image2),
                 Wx::Bitmap.new(image3)]
      bundle = Wx::BitmapBundle.from_bitmaps(bitmaps)
      return bundle
    else
      bundle = Wx::BitmapBundle.from_bitmaps(Wx::Bitmap.new(image1),
                                             Wx::Bitmap.new(image2))
      return bundle
    end
  end
  bundle = Wx::BitmapBundle.from_image(image1)
  return bundle
end
)===";

inline constexpr const auto txt_ruby_get_animation =
R"===(
# Loads image from a string and returns a Wx::Animation object.
def get_animation(image_name)
  animation = Wx::Animation.new
  animation.load(StringIO.new(image_name))
  return animation
end
)===";

// clang-format on

// This *must* be written on a line by itself with *no* indentation.
const char* ruby_begin_cmt_block = "=begin";

// This *must* be written on a line by itself with *no* indentation.
const char* ruby_end_cmt_block = "=end";

#if defined(_DEBUG)
// clang-format off
static const std::vector<tt_string> disable_list = {
    "Metrics/MethodLength",
    "Metrics/ParameterLists",
    "Style/Documentation",
    "Style/BlockComments",
    "Metrics/AbcSize",
};
// clang-format on
#endif  // _DEBUG

// Equivalent to GenerateBaseClass in gen_base.cpp

void BaseCodeGenerator::GenerateRubyClass(PANEL_PAGE panel_type)
{
    Code code(m_form_node, GEN_LANG_RUBY);

    m_embedded_images.clear();

    bool base64_requirement_written = false;
    bool stringio_requirement_written = false;
    bool zlib_requirement_written = false;

    m_NeedAnimationFunction = false;
    m_NeedImageFunction = false;
    m_NeedSVGFunction = false;

    SetImagesForm();
    std::set<std::string> img_include_set;

    std::thread thrd_get_events(&BaseCodeGenerator::CollectEventHandlers, this, m_form_node, std::ref(m_events));
    std::thread thrd_need_img_func(&BaseCodeGenerator::ParseImageProperties, this, m_form_node);
    std::thread thrd_collect_img_headers(&BaseCodeGenerator::CollectImageHeaders, this, m_form_node,
                                         std::ref(img_include_set));

    // If the code files are being written to disk, then UpdateEmbedNodes() has already been called.
    if (panel_type != NOT_PANEL)
    {
        ProjectImages.UpdateEmbedNodes();
    }

    std::vector<Node*> forms;
    Project.CollectForms(forms);

    m_panel_type = panel_type;

    m_header->Clear();
    m_source->Clear();
    m_source->SetTabToSpaces(2);
    m_source->SetLastLineBlank();

#if !defined(_DEBUG)
    if (m_panel_type == NOT_PANEL)
#else
    if (m_panel_type != NOT_PANEL)
    {
        m_source->writeLine(
            "# The following comment block is only displayed in a _DEBUG build, or when written to a file.\n\n");
    }
#endif  // _DEBUG
    {
        m_source->writeLine(txt_PoundCmtBlock);

        if (Project.as_bool(prop_disable_rubo_cop))
        {
#if defined(_DEBUG)
            for (auto& iter: disable_list)
            {
                m_source->writeLine("# rubocop:disable " + iter);
            }
#else
            m_source->writeLine("# rubocop:disable all");
#endif
            m_source->writeLine();
        }

        if (Project.hasValue(prop_ruby_project_preamble))
        {
            WritePropSourceCode(Project.getProjectNode(), prop_ruby_project_preamble);
        }
    }

    m_source->writeLine("WX_GLOBAL_CONSTANTS = true unless defined? WX_GLOBAL_CONSTANTS\n\nrequire 'wx/core'");

    if (m_form_node->isGen(gen_Images))
    {
        m_source->writeLine();
        m_source->writeLine("require 'base64'");
        m_source->writeLine("require 'stringio'");
        m_source->writeLine();

        thrd_get_events.join();
        try
        {
            thrd_collect_img_headers.join();
        }
        catch (const std::system_error& err)
        {
#if defined(_DEBUG)
            MSG_ERROR(err.what());
#else
            wxMessageDialog dlg_error(nullptr, wxString::FromUTF8(err.what()), "Internal Thread Error", wxICON_ERROR | wxOK);
            dlg_error.ShowModal();
#endif  // _DEBUG
        }

        thrd_need_img_func.join();
        GenerateRubyImagesForm();
        return;
    }

    m_header->writeLine("WX_GLOBAL_CONSTANTS = true unless defined? WX_GLOBAL_CONSTANTS\n\nrequire 'wx/core'");
    m_header->writeLine(tt_string("# Sample inherited class from ") << m_form_node->as_string(prop_class_name));
    m_header->writeLine();

    std::set<std::string> imports;

    auto GatherImportModules = [&](Node* node, auto&& GatherImportModules) -> void
    {
        if (auto* gen = node->getGenerator(); gen)
        {
            gen->GetImports(node, imports, GEN_LANG_RUBY);
        }
        for (auto& child: node->getChildNodePtrs())
        {
            GatherImportModules(child.get(), GatherImportModules);
        }
    };
    GatherImportModules(m_form_node, GatherImportModules);

    for (const auto& import: imports)
    {
        m_source->writeLine(import);
        m_header->writeLine(import);
    }
    m_source->writeLine();
    m_header->writeLine();

    if (m_form_node->hasValue(prop_relative_require_list))
    {
        tt_string_vector list;
        list.SetString(m_form_node->as_string(prop_relative_require_list));
        for (auto& iter: list)
        {
            iter.remove_extension();
            m_source->writeLine(tt_string("require_relative '") << iter << '\'');
        }
        if (list.size())
        {
            m_source->writeLine();
        }
    }

    if (m_form_node->isGen(gen_wxFrame) && m_form_node->as_bool(prop_import_all_dialogs))
    {
        for (auto& form: forms)
        {
            if ((form->isGen(gen_wxDialog) || form->isGen(gen_wxWizard)) && form->hasValue(prop_ruby_file))
            {
                tt_string import_name(form->as_string(prop_ruby_file).filename());
                import_name.remove_extension();
                m_source->writeLine(tt_string("require_relative '") << import_name << "'");
            }
        }
    }

    m_set_enum_ids.clear();
    m_set_const_ids.clear();
    BaseCodeGenerator::CollectIDs(m_form_node, m_set_enum_ids, m_set_const_ids);

    int id_value = wxID_HIGHEST;
    for (auto& iter: m_set_enum_ids)
    {
        m_source->writeLine(tt_string() << '$' << iter << " = " << id_value++);
    }
    for (auto& iter: m_set_const_ids)
    {
        if (tt::contains(iter, " wx"))
        {
            tt_string id = '$' + iter;
            id.Replace(" wx", " Wx::", true, tt::CASE::exact);
            m_source->writeLine(id);
        }
        else
        {
            m_source->writeLine('$' + iter);
        }
    }

    try
    {
        thrd_collect_img_headers.join();
    }
    catch (const std::system_error& err)
    {
#if defined(_DEBUG)
        MSG_ERROR(err.what());
#else
        wxMessageDialog dlg_error(nullptr, wxString::FromUTF8(err.what()), "Internal Thread Error", wxICON_ERROR | wxOK);
        dlg_error.ShowModal();
#endif  // _DEBUG
    }

    if (m_embedded_images.size())
    {
        m_source->writeLine();

        // First see if we need to import the gen_Images List
        bool images_file_imported = false;
        bool svg_import_libs = false;
        for (auto& iter: m_embedded_images)
        {
            if (iter->form == m_ImagesForm)
            {
                if (!images_file_imported)
                {
                    tt_string import_name = iter->form->as_string(prop_ruby_file).filename();
                    import_name.remove_extension();
                    code.Str("require_relative '").Str(import_name) << "'";
                    m_source->writeLine(code);
                    code.clear();
                    images_file_imported = true;
                }
                if (iter->imgs[0].type == wxBITMAP_TYPE_SVG)
                {
                    if (!zlib_requirement_written)
                    {
                        zlib_requirement_written = true;
                        m_source->writeLine("require 'zlib'");
                    }
                    if (!base64_requirement_written)
                    {
                        base64_requirement_written = true;
                        m_source->writeLine("require 'base64'");
                    }
                    if (!stringio_requirement_written)
                    {
                        stringio_requirement_written = true;
                        m_source->writeLine("require 'stringio'");
                    }
                    svg_import_libs = true;
                }
            }
            else if (!svg_import_libs)
            {
                if (iter->imgs[0].type == wxBITMAP_TYPE_SVG)
                {
                    if (!zlib_requirement_written)
                    {
                        zlib_requirement_written = true;
                        m_source->writeLine("require 'zlib'");
                    }
                    if (!base64_requirement_written)
                    {
                        base64_requirement_written = true;
                        m_source->writeLine("require 'base64'");
                    }
                    if (!stringio_requirement_written)
                    {
                        stringio_requirement_written = true;
                        m_source->writeLine("require 'stringio'");
                    }
                    svg_import_libs = true;
                }
                if (iter->form != m_ImagesForm)
                {
                    // If the image isn't in the images file, then we need to add the base64 version
                    // of the bitmap
                    if (!base64_requirement_written)
                    {
                        base64_requirement_written = true;
                        m_source->writeLine("require 'base64'");
                    }

                    // At this point we know that some method is required, but until we have
                    // processed all the images, we won't know if the images file is required.
                    // The images file provides it's own function for loading images, so we can
                    // use that if it's available.
                    m_NeedImageFunction = true;
                }
            }
        }
        if (m_NeedImageFunction)
        {
            if (images_file_imported)
                // The images file supplies the function we need
                m_NeedImageFunction = false;
            else
            {
                // We have to provide our own method, and that requires this library
                if (!stringio_requirement_written)
                {
                    // No further check for this is needed
                    // stringio_requirement_written = true;
                    m_source->writeLine("require 'stringio'");
                }
            }
        }
    }

    m_source->writeLine();
    m_header->writeLine();
    m_header->writeLine(tt_string("requires '") << m_form_node->as_string(prop_ruby_file) << "'\n");
    m_header->writeLine();

    if (m_form_node->hasValue(prop_ruby_insert))
    {
        tt_string convert(m_form_node->as_string(prop_ruby_insert));
        convert.Replace("@@", "\n", tt::REPLACE::all);
        tt_string_vector lines(convert, '\n', tt::TRIM::right);
        for (auto& line: lines)
        {
            m_source->doWrite(line);
            m_source->doWrite("\n");
        }
        m_source->doWrite("\n");
    }

    tt_string inherit_name = m_form_node->as_string(prop_ruby_inherit_name);
    if (inherit_name.empty())
    {
        inherit_name += "Sample < " + m_form_node->as_string(prop_class_name);
    }
    if (inherit_name.size())
    {
        tt_string inherit("class ");
        inherit << inherit_name;
        inherit << m_form_node->as_string(prop_ruby_file) << "." << m_form_node->as_string(prop_class_name) << "):";

        m_header->writeLine(inherit);
        m_header->Indent();
        m_header->writeLine("def initialize(parent)");
        m_header->writeLine("end");
        m_header->Unindent();
        m_header->writeLine();
    }

    auto generator = m_form_node->getNodeDeclaration()->getGenerator();
    code.clear();
    if (generator->ConstructionCode(code))
    {
        m_source->writeLine(code);
        m_source->writeLine();
        m_source->Indent();
        m_source->Indent();
    }

    code.clear();
    if (generator->SettingsCode(code))
    {
        if (code.size())
        {
            m_source->writeLine(code);
            m_source->writeLine();
        }
    }

    if (m_form_node->getPropPtr(prop_window_extra_style))
    {
        code.clear();
        code.GenWindowSettings();
        if (code.size())
        {
            m_source->writeLine(code);
        }
    }

    m_source->SetLastLineBlank();
    for (const auto& child: m_form_node->getChildNodePtrs())
    {
        if (child->isGen(gen_wxContextMenuEvent))
            continue;
        GenConstruction(child.get());
    }

    code.clear();
    if (generator->AfterChildrenCode(code))
    {
        if (code.size())
        {
            m_source->writeLine();
            m_source->writeLine(code);
        }
    }

    if (m_form_node->as_bool(prop_persist))
    {
        m_source->writeLine();
        tt_string tmp("Wx.persistent_register_and_restore(self, \"");
        tmp << m_form_node->getNodeName() << "\");";
        m_source->writeLine(tmp);
    }

    auto rlambda = [&](Node* node, auto&& rlambda) -> void
    {
        if (node->hasValue(prop_persist_name))
        {
            tt_string code("Wx.persistent_register_and_restore(");
            code << node->getNodeName() << ", \"" << node->as_string(prop_persist_name) << "\");";
            m_source->writeLine(code);
        }

        for (const auto& child: node->getChildNodePtrs())
        {
            rlambda(child.get(), rlambda);
        }
    };

    rlambda(m_form_node, rlambda);

    // Timer code must be created before the events, otherwise the timer variable won't exist
    // when the event is created.

    code.clear();
    if (TimerGenerator::StartIfChildTimer(m_form_node, code))
    {
        m_source->writeLine(code);
        m_source->writeLine();
    }

    // Delay calling join() for as long as possible to increase the chance that the thread will
    // have already completed.
    thrd_get_events.join();
    if (m_events.size())
    {
        m_source->writeLine();
        m_source->writeLine("# Event handlers");
        GenSrcEventBinding(m_form_node, m_events);

        m_source->writeLine("\tend", indent::none);
        m_source->SetLastLineBlank();

        m_source->ResetIndent();
        m_source->writeLine();
        m_source->Indent();
        GenRubyEventHandlers(m_events);
    }
    else
    {
        m_source->ResetIndent();
        m_source->writeLine("\tend", indent::none);
    }
    m_header->ResetIndent();
    m_header->writeLine("end", indent::none);

    thrd_need_img_func.join();

    if (m_NeedImageFunction)
    {
        m_source->doWrite("\n");  // force an extra line break
        m_source->writeLine(txt_ruby_get_bundle, indent::auto_keep_whitespace);
    }

    if (m_NeedAnimationFunction)
    {
        if (!m_NeedImageFunction)
            m_source->doWrite("\n");  // force an extra line break
        m_source->writeLine(txt_ruby_get_animation, indent::auto_keep_whitespace);
    }

    if (m_form_node->isGen(gen_wxWizard))
    {
        code.clear();
        // see for an example C:\rwCode\wxRuby3\samples\dialogs\wizard.rb
        // w = MyWizard.new(self)
        // w.run_wizard(w.get_page_area_sizer.get_item(0).get_window)
    }

    // Make certain indentation is reset after all construction code is written
    m_source->ResetIndent();

    m_header->ResetIndent();

    code.clear();
    // Now write any embedded images that aren't declared in the gen_Images List
    for (auto& iter: m_embedded_images)
    {
        // Only write the images that aren't declared in any gen_Images List. Note that
        // this *WILL* result in duplicate images being written to different forms.
        if (iter->form != m_ImagesForm)
        {
            WriteImageConstruction(code);
            m_source->doWrite("\n");  // force an extra line break
            m_source->SetLastLineBlank();
            break;
        }
    }

#if !defined(_DEBUG)
    if (m_panel_type == NOT_PANEL)
#endif  // _DEBUG
    {
        if (Project.as_bool(prop_disable_rubo_cop))
        {
            m_source->writeLine();
#if defined(_DEBUG)
            for (auto& iter: disable_list)
            {
                m_source->writeLine("# rubocop:enable " + iter);
            }
#else
            m_source->writeLine("# rubocop:enable all");
#endif  // _DEBUG
            m_source->writeLine();
        }
    }
}

tt_string MakeRubyPath(Node* node)
{
    auto [path, has_base_file] = Project.GetOutputPath(node->getForm(), GEN_LANG_RUBY);
    if (path.empty())
        path = "./";
    else if (has_base_file)
        path.remove_filename();
    return path;
}

bool RubyBundleCode(Code& code, GenEnum::PropName prop)
{
    auto& description = code.node()->as_string(prop);
    if (description.empty())
    {
        code.Add("wxNullBitmap");
        return false;
    }

    tt_view_vector parts(description, BMP_PROP_SEPARATOR, tt::TRIM::both);

    if (parts.size() <= 1 || parts[IndexImage].empty())
    {
        code.Add("wxNullBitmap");
        return false;
    }

    if (parts[IndexType].contains("Art"))
    {
        tt_string art_id(parts[IndexArtID]);
        tt_string art_client;
        if (auto pos = art_id.find('|'); tt::is_found(pos))
        {
            art_client = art_id.subview(pos + 1);
            art_id.erase(pos);
        }

        code.Str("Wx::ArtProvider.get_bitmap_bundle(").Add(art_id);

        // Note that current documentation states that the client is required, but the header file says otherwise
        if (art_client.size())
            code.Comma().Add(art_client);

        if (parts.size() > IndexSize && parts[IndexSize].size())
        {
            wxSize svg_size { -1, -1 };
            svg_size = GetSizeInfo(parts[IndexSize]);

            if (svg_size != wxDefaultSize)
            {
                code.Comma();
                code.CheckLineLength(sizeof("Wx::Size.new(999, 999)))"));
                code << "Wx::Size.new(" << svg_size.x << ", " << svg_size.y << ')';
            }
        }
        code << ')';
        return true;
    }

    if (auto bundle = ProjectImages.GetPropertyImageBundle(description); bundle && bundle->lst_filenames.size())
    {
        if (description.starts_with("SVG"))
        {
            auto embed = ProjectImages.GetEmbeddedImage(parts[IndexImage]);
            ASSERT(embed);
            tt_string svg_name;
            if (embed->form != code.node()->getForm())
            {
                svg_name = embed->form->as_string(prop_ruby_file).filename();
                svg_name.remove_extension();
                svg_name << ".$" << embed->imgs[0].array_name;
            }
            else
            {
                svg_name = "$" + embed->imgs[0].array_name;
            }
            code.insert(0, tt_string("_svg_string_ = Zlib::Inflate.inflate(Base64.decode64(") << svg_name << "))\n");
            code += "Wx::BitmapBundle.from_svg(_svg_string_";
            wxSize svg_size { -1, -1 };
            if (parts[IndexSize].size())
            {
                svg_size = GetSizeInfo(parts[IndexSize]);
            }
            code.Comma().Str("Wx::Size.new(").itoa(svg_size.x).Comma().itoa(svg_size.y) += "))";
        }

        else if (description.starts_with("XPM"))
        {
            auto path = MakeRubyPath(code.node());
            tt_string name(bundle->lst_filenames[0]);
            name.make_absolute();
            if (!name.file_exists())
            {
                name = Project.ArtDirectory();
                name.append_filename(bundle->lst_filenames[0]);
            }
            name.make_relative(path);
            name.backslashestoforward();

            code.CheckLineLength(name.size() + sizeof("Wx::Bitmap.new()") + sizeof("wx.BITMAP_TYPE_XPM)"));
            code.Str("Wx::Bitmap.new(").QuotedString(name).Comma().Str("Wx::BITMAP_TYPE_XPM)");
        }

        else if (parts[IndexType].starts_with("Embed"))
        {
            if (bundle->lst_filenames.empty())
            {
                code.Add("wxNullBitmap");
                return false;
            }
            if (const EmbeddedImage* embed1 = ProjectImages.GetEmbeddedImage(bundle->lst_filenames[0]); embed1)
            {
                code.Str("wxue_get_bundle(").Str("$").Str(embed1->imgs[0].array_name);
                if (bundle->lst_filenames.size() > 1)
                {
                    if (EmbeddedImage* embed2 = ProjectImages.GetEmbeddedImage(bundle->lst_filenames[1]); embed2)
                    {
                        code.Comma().Str("$").Str(embed2->imgs[0].array_name);
                    }
                    if (bundle->lst_filenames.size() > 2)
                    {
                        if (EmbeddedImage* embed3 = ProjectImages.GetEmbeddedImage(bundle->lst_filenames[2]); embed3)
                        {
                            code.Comma().Str("$").Str(embed3->imgs[0].array_name);
                        }
                    }
                }
                code += ')';
                return true;
            }
        }
        else if (bundle->lst_filenames.size() == 1)
        {
            auto path = Project.getBaseDirectory(code.node(), GEN_LANG_RUBY);

            tt_string name(bundle->lst_filenames[0]);
            name.make_absolute();
            name.make_relative(path);
            name.backslashestoforward();

            code.CheckLineLength(name.size() + name.size() + 27);
            code.Str("Wx::Bitmap(").QuotedString(name).Str("))");
        }
        else if (bundle->lst_filenames.size() == 2)
        {
            auto path = Project.getBaseDirectory(code.node(), GEN_LANG_RUBY);

            tt_string name(bundle->lst_filenames[0]);
            name.make_absolute();
            name.make_relative(path);
            name.backslashestoforward();

            tt_string name2(bundle->lst_filenames[1]);
            name2.make_absolute();
            name2.make_relative(path);
            name2.backslashestoforward();

            code.CheckLineLength(name.size() + name2.size() + 27);
            code.Str("Wx::Bitmap(").QuotedString(name).Str(", Wx::Bitmap(").QuotedString(name2).Str("))");
        }

        else
        {
            FAIL_MSG("Unexpected number of images in bundle -- should be <= 2");
            code.Add("wxNullBitmap");
            return false;
        }
    }
    else
    {
        FAIL_MSG("Missing bundle description");
        code.Add("wxNullBitmap");
        return false;
    }

    return false;
}
