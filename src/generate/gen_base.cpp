/////////////////////////////////////////////////////////////////////////////
// Purpose:   Generate Src and Hdr files for the Base Class
// Author:    Ralph Walden
// Copyright: Copyright (c) 2020-2022 KeyWorks Software (Ralph Walden)
// License:   Apache License -- see ../../LICENSE
/////////////////////////////////////////////////////////////////////////////

#include <future>
#include <thread>
#include <unordered_set>

#include <wx/filename.h>  // wxFileName - encapsulates a file path

#include <tttextfile_wx.h>  // textfile -- Classes for reading and writing line-oriented files

#include "gen_base.h"

#include "code.h"           // Code -- Helper class for generating code
#include "gen_common.h"     // GeneratorLibrary -- Generator classes
#include "node.h"           // Node class
#include "node_creator.h"   // NodeCreator class
#include "node_decl.h"      // NodeDeclaration class
#include "project_class.h"  // Project class
#include "utils.h"          // Utility functions that work with properties
#include "write_code.h"     // Write code to Scintilla or file

using namespace GenEnum;

// clang-format off

inline constexpr const auto txt_wxueImageFunction = R"===(
// Convert a data array into a wxImage
inline wxImage wxueImage(const unsigned char* data, size_t size_data)
{
    wxMemoryInputStream strm(data, size_data);
    wxImage image;
    image.LoadFile(strm);
    return image;
};
)===";

inline constexpr const auto txt_GetBundleFromSVG = R"===(
// Convert compressed SVG string into a wxBitmapBundle
inline wxBitmapBundle wxueBundleSVG(const unsigned char* data,
    size_t size_data, size_t size_svg, wxSize def_size)
{
    auto str = std::make_unique<char[]>(size_svg);
    wxMemoryInputStream stream_in(data, size_data);
    wxZlibInputStream zlib_strm(stream_in);
    zlib_strm.Read(str.get(), size_svg);
    return wxBitmapBundle::FromSVG(str.get(), def_size);
};
)===";

inline constexpr const auto txt_GetAnimFromHdrFunction = R"===(
// Convert a data array into a wxAnimation
inline wxAnimation wxueAnimation(const unsigned char* data, size_t size_data)
{
    wxMemoryInputStream strm(data, size_data);
    wxAnimation animation;
    animation.Load(strm);
    return animation;
};
)===";

inline constexpr const auto txt_BaseCmtBlock =
R"===(///////////////////////////////////////////////////////////////////////////////
// Code generated by wxUiEditor - see https://github.com/KeyWorksRW/wxUiEditor/
//
// Do not edit any code above the "End of generated code" comment block.
// Any changes before that block will be lost if it is re-generated!
///////////////////////////////////////////////////////////////////////////////

// clang-format off

)===";

// clang-format on

std::map<wxBitmapType, std::string> g_map_handlers;
std::map<wxBitmapType, std::string> g_map_types;

#define ADD_TYPE(name) g_map_types[name] = #name;

BaseCodeGenerator::BaseCodeGenerator(int language)
{
    m_language = language;

    if (g_map_types.empty())
    {
        ADD_TYPE(wxBITMAP_TYPE_BMP);  // We include this, but the handler is always loaded
        ADD_TYPE(wxBITMAP_TYPE_ICO);
        ADD_TYPE(wxBITMAP_TYPE_CUR);
        ADD_TYPE(wxBITMAP_TYPE_XPM);
        ADD_TYPE(wxBITMAP_TYPE_TIFF);
        ADD_TYPE(wxBITMAP_TYPE_GIF);
        ADD_TYPE(wxBITMAP_TYPE_PNG);
        ADD_TYPE(wxBITMAP_TYPE_JPEG);
        ADD_TYPE(wxBITMAP_TYPE_PNM);
        ADD_TYPE(wxBITMAP_TYPE_PCX);
        ADD_TYPE(wxBITMAP_TYPE_ANI);
        ADD_TYPE(wxBITMAP_TYPE_TGA);

        g_map_handlers[wxBITMAP_TYPE_ICO] = "wxICOHandler";
        g_map_handlers[wxBITMAP_TYPE_CUR] = "wxCURHandler";
        g_map_handlers[wxBITMAP_TYPE_XPM] = "wxXPMHandler";
        g_map_handlers[wxBITMAP_TYPE_TIFF] = "wxTIFFHandler";
        g_map_handlers[wxBITMAP_TYPE_GIF] = "wxGIFHandler";
        g_map_handlers[wxBITMAP_TYPE_PNG] = "wxPNGHandler";
        g_map_handlers[wxBITMAP_TYPE_JPEG] = "wxJPEGHandler";
        g_map_handlers[wxBITMAP_TYPE_PNM] = "wxPNMHandler";
        g_map_handlers[wxBITMAP_TYPE_PCX] = "wxPCXHandler";
        g_map_handlers[wxBITMAP_TYPE_ANI] = "wxANIHandler";
        g_map_handlers[wxBITMAP_TYPE_TGA] = "wxTGAHandler";
    }
}

void BaseCodeGenerator::GenerateBaseClass(Node* form_node, PANEL_PAGE panel_type)
{
    ASSERT(form_node)
    ASSERT(m_language == GEN_LANG_CPLUSPLUS)

    m_CtxMenuEvents.clear();
    m_embedded_images.clear();
    m_type_generated.clear();

    m_project = GetProject();
    m_form_node = form_node;
    m_ImagesForm = nullptr;

    for (const auto& form: m_project->GetChildNodePtrs())
    {
        if (form->isGen(gen_folder))
        {
            for (const auto& child_form: form->GetChildNodePtrs())
            {
                if (child_form->isGen(gen_Images))
                {
                    m_ImagesForm = child_form.get();
                    break;
                }
            }
            break;
        }

        else if (form->isGen(gen_Images))
        {
            m_ImagesForm = form.get();
            break;
        }
    }

    m_NeedAnimationFunction = false;
    m_NeedHeaderFunction = false;
    m_NeedSVGFunction = false;
    m_NeedArtProviderHeader = false;
    m_NeedImageFunction = false;

    EventVector events;
    std::thread thrd_get_events(&BaseCodeGenerator::CollectEventHandlers, this, form_node, std::ref(events));
    std::thread thrd_need_img_func(&BaseCodeGenerator::ParseImageProperties, this, form_node);

    // If the code files are being written to disk, then UpdateEmbedNodes() has already been called.
    if (panel_type != NOT_PANEL)
    {
        GetProject()->UpdateEmbedNodes();
    }

    m_panel_type = panel_type;

    m_header->Clear();
    m_source->Clear();
    m_source->SetLastLineBlank();
    m_header->SetLastLineBlank();

    if (m_panel_type == NOT_PANEL)
    {
        m_header->writeLine(txt_BaseCmtBlock);
        m_source->writeLine(txt_BaseCmtBlock);
    }

    ttlib::cstr file;
    if (auto& base_file = form_node->prop_as_string(prop_base_file); base_file.size())
    {
        ttSaveCwd cwd;
        ttlib::ChangeDir(GetProject()->getProjectPath());
        file = base_file;
        file.make_relative(GetProject()->getProjectPath());
        file.backslashestoforward();
        file.remove_extension();

        m_baseFullPath = base_file;
        m_baseFullPath.make_absolute();
        m_baseFullPath.remove_filename();
    }

    // Caution! CollectImageHeaders() needs access to m_baseFullPath, so don't start this thread until it has been set!
    std::set<std::string> img_include_set;
    std::thread thrd_collect_img_headers(&BaseCodeGenerator::CollectImageHeaders, this, form_node,
                                         std::ref(img_include_set));

    m_header->writeLine("#pragma once");
    m_header->writeLine();

    std::set<std::string> src_includes;
    std::set<std::string> hdr_includes;
    if (m_project->prop_as_string(prop_help_provider) != "none")
        src_includes.insert("#include <wx/cshelp.h>");
    if (m_project->prop_as_bool(prop_internationalize))
        hdr_includes.insert("#include <wx/intl.h>");

    // This will almost always be needed, and it in turn includes a bunch of other files like string.h which are also
    // almost always needed.
    hdr_includes.insert("#include <wx/gdicmn.h>");

    CollectIncludes(form_node, src_includes, hdr_includes);

    thrd_get_events.join();
    if (events.size() || m_CtxMenuEvents.size())
    {
        hdr_includes.insert("#include <wx/event.h>");
    }

    if (panel_type != CPP_PANEL)
    {
        // BUGBUG: [KeyWorks - 01-25-2021] Need to look for base_class_name property of all children, and add each name
        // as a forwarded class.

        // First output all the wxWidget header files
        for (auto& iter: hdr_includes)
        {
            if (ttlib::contains(iter, "<wx"))
                m_header->writeLine((ttlib::cstr&) iter);
        }

        m_header->writeLine();

        // Now output all the other header files (this will include forward class declarations)
        for (auto& iter: hdr_includes)
        {
            if (!ttlib::contains(iter, "<wx"))
                m_header->writeLine((ttlib::cstr&) iter);
        }

        m_header->writeLine();

        if (form_node->HasValue(prop_base_hdr_includes))
        {
            WritePropHdrCode(form_node, prop_base_hdr_includes);
        }
    }

    if (m_project->HasValue(prop_local_pch_file))
    {
        m_source->writeLine(ttlib::cstr() << "#include \"" << m_project->prop_as_string(prop_local_pch_file) << '"');
        m_source->writeLine();
    }

    if (form_node->prop_as_bool(prop_persist))
    {
        src_includes.insert("#include <wx/persist.h>");
        src_includes.insert("#include <wx/persist/toplevel.h>");
    }

    if (form_node->HasValue(prop_icon))
    {
        src_includes.insert("#include <wx/icon.h>");
    }

    thrd_need_img_func.join();

    if (m_NeedArtProviderHeader)
    {
        src_includes.insert("#include <wx/artprov.h>");
    }

    // Make certain there is a blank line before the the wxWidget #includes
    m_source->writeLine();

    // All generators that use a wxBitmapBundle should add "#include <wx/bmpbndl.h>" to the header set. If the user specified
    // 3.1 for the wxWidgets library, then code generation will create conditional code that uses wxBitmapBundle if 3.1.6 or
    // wxBitmap if older. We need to conditionalize the header output by removing the "#include <wx/bmpbndl.h>" entry and
    // creating our own conditionalized header.

    if (wxGetProject().value(prop_wxWidgets_version) == "3.1")
    {
        if (auto bmpbndl_hdr = src_includes.find("#include <wx/bmpbndl.h>"); bmpbndl_hdr != src_includes.end())
        {
            src_includes.erase(bmpbndl_hdr);
            if (auto bitmap_hdr = src_includes.find("#include <wx/bitmap.h>"); bitmap_hdr != src_includes.end())
            {
                src_includes.erase(bitmap_hdr);
            }

            ttlib::cstr code("#if wxCHECK_VERSION(3, 1, 6)\n\t");
            code << "#include <wx/bmpbndl.h>";
            code << "\n#else\n\t";
            code << "#include <wx/bitmap.h>";
            code << "\n#endif";
            m_source->writeLine(code, indent::auto_keep_whitespace);
            m_source->writeLine();
        }
    }

    // First output all the wxWidget header files
    for (auto& iter: src_includes)
    {
        if (ttlib::contains(iter, "<wx"))
            m_source->writeLine((ttlib::cstr&) iter);
    }

    m_source->writeLine();

    // Now output all the other header files (this will include derived_class header files)
    for (auto& iter: src_includes)
    {
        if (!ttlib::contains(iter, "<wx"))
            m_source->writeLine((ttlib::cstr&) iter);
    }

    m_source->writeLine();

    if (m_project->HasValue(prop_src_preamble))
    {
        WritePropSourceCode(m_project, prop_src_preamble);
    }

    if (form_node->HasValue(prop_base_src_includes))
    {
        WritePropSourceCode(form_node, prop_base_src_includes);
    }

    if (auto& hdr_extension = m_project->prop_as_string(prop_header_ext); hdr_extension.size())
    {
        m_header_ext = hdr_extension;
    }

    if (file.empty())
    {
        m_source->writeLine();
        m_source->writeLine("// Specify the filename to use in the base_file property");
        m_source->writeLine("#include \"Your filename here\"");
    }
    else
    {
        file.replace_extension(m_header_ext);
        m_source->writeLine();
        m_source->writeLine(ttlib::cstr() << "#include \"" << file.filename() << "\"");
    }

    m_source->writeLine();

    thrd_collect_img_headers.join();
    std::sort(m_embedded_images.begin(), m_embedded_images.end(),
              [](const EmbeddedImage* a, const EmbeddedImage* b)
              {
                  return (a->array_name.compare(b->array_name) < 0);
              });

    if (m_panel_type != HDR_PANEL)
    {
        if (!img_include_set.empty())
        {
            for (auto& iter: img_include_set)
            {
                m_source->writeLine(iter.c_str());
            }

            m_source->writeLine();
        }
    }

    // Make a copy of the string so that we can tweak it
    ttlib::cstr namespace_prop = m_project->prop_as_string(prop_name_space);
    if (auto* node_namespace = form_node->get_folder(); node_namespace && node_namespace->HasValue(prop_folder_namespace))
    {
        namespace_prop = node_namespace->as_string(prop_folder_namespace);
    }
    size_t indent = 0;
    ttlib::multistr names;
    if (namespace_prop.size())
    {
        // BUGBUG: [KeyWorks - 09-01-2021] ttlib::multistr works fine with a string as the separator. So does
        // ttlib::multiview which is what we should be using here.

        // ttlib::multistr works with a single char, not a string.
        namespace_prop.Replace("::", ":");
        // we also accept using semi-colons to separate the namespaces
        namespace_prop.Replace(";", ":");
        names.SetString(namespace_prop, ':');
        ttlib::cstr using_name;
        m_header->writeLine();
        for (auto& iter: names)
        {
            m_header->writeLine(ttlib::cstr() << "namespace " << iter);
            m_header->writeLine("{");
            m_header->Indent();
            ++indent;

            if (using_name.empty())
            {
                using_name = "using namespace ";
            }
            else
            {
                using_name += "::";
            }
            using_name += iter;
        }
        m_header->SetLastLineBlank();

        if (using_name.size())
        {
            using_name << ';';
            m_source->writeLine(using_name);
        }
    }

    if (form_node->isGen(gen_Images))
    {
        GenerateImagesForm();
        return;
    }

    if (m_panel_type != CPP_PANEL)
        GenerateClassHeader(form_node, events);

    if (m_panel_type != HDR_PANEL)
    {
        // First, generate the header files needed

        m_source->writeLine();
        if (m_NeedAnimationFunction)
        {
            m_source->writeLine("#include <wx/animate.h>", indent::none);
        }
        if (m_NeedImageFunction || m_NeedHeaderFunction || m_NeedSVGFunction || m_NeedAnimationFunction)
        {
            m_source->writeLine("\n#include <wx/mstream.h>  // memory stream classes", indent::none);
        }
        if (m_NeedSVGFunction)
        {
            m_source->writeLine("#include <wx/zstream.h>  // zlib stream classes", indent::none);
            m_source->writeLine();
            m_source->writeLine("#include <memory>  // for std::make_unique", indent::none);
        }

        // Now generate the functions

        if (m_NeedImageFunction || m_NeedHeaderFunction)
        {
            ttlib::textfile function;
            function.ReadString(txt_wxueImageFunction);
            for (auto& iter: function)
            {
                m_source->writeLine(iter, indent::none);
            }
            m_source->writeLine();
        }

        if (m_NeedSVGFunction)
        {
            if (wxGetProject().value(prop_wxWidgets_version) == "3.1")
            {
                m_source->writeLine();
                m_source->writeLine("#if !wxCHECK_VERSION(3, 1, 6)", indent::none);
                m_source->Indent();
                m_source->writeLine("#error \"You must build with wxWidgets 3.1.6 or later to use SVG images.\"",
                                    indent::auto_no_whitespace);
                m_source->Unindent();
                m_source->writeLine("#endif", indent::none);
            }

            ttlib::textfile function;
            function.ReadString(txt_GetBundleFromSVG);
            for (auto& iter: function)
            {
                m_source->writeLine(iter, indent::none);
            }
            m_source->writeLine();
        }

        if (m_NeedAnimationFunction)
        {
            ttlib::textfile function;
            function.ReadString(txt_GetAnimFromHdrFunction);
            for (auto& iter: function)
            {
                m_source->writeLine(iter, indent::none);
            }
        }

        if (m_embedded_images.size())
        {
            bool isNameSpaceWritten = false;
            for (auto iter_array: m_embedded_images)
            {
                // If the image is defined in this form, then it will already have been declared in the class's header file.
                // For the source code, we only care about images defined in another source module.

                if (iter_array->form == m_form_node)
                    continue;

                if (!isNameSpaceWritten)
                {
                    isNameSpaceWritten = true;
                    m_source->writeLine();
                    m_source->writeLine("namespace wxue_img\n{");
                    m_source->Indent();
                }

                m_source->writeLine(ttlib::cstr("extern const unsigned char ")
                                    << iter_array->array_name << '[' << (iter_array->array_size & 0xFFFFFFFF) << "];");
            }
            if (isNameSpaceWritten)
            {
                m_source->Unindent();
                m_source->writeLine("}\n");
            }
        }

        GenerateClassConstructor(form_node, events);

        if (m_embedded_images.size())
        {
            bool is_namespace_written = false;
            for (auto iter_array: m_embedded_images)
            {
                if (iter_array->form != m_form_node)
                    continue;

                if (!is_namespace_written)
                {
                    m_source->writeLine();
                    m_source->writeLine("namespace wxue_img\n{");
                    m_source->Indent();
                    is_namespace_written = true;
                }
                m_source->writeLine();
                ttlib::cstr code;
                code.reserve(max_image_line_length + 16);
                // SVG images store the original size in the high 32 bits
                size_t max_pos = (iter_array->array_size & 0xFFFFFFFF);
                code << "const unsigned char " << iter_array->array_name << '[' << max_pos << "] {";

                m_source->writeLine(code);

                size_t pos = 0;
                while (pos < max_pos)
                {
                    code.clear();
                    // -8 to account for 4 indent + max 3 chars for number + comma
                    for (; pos < max_pos && code.size() < (to_size_t) max_image_line_length - 8; ++pos)
                    {
                        code << (to_int) iter_array->array_data[pos] << ',';
                    }
                    if (pos >= max_pos && code.back() == ',')
                        code.pop_back();
                    m_source->writeLine(code);
                }
                m_source->writeLine("};");
            }
            if (is_namespace_written)
            {
                m_source->writeLine();
                m_source->Unindent();
                m_source->writeLine("}\n");
            }
        }
    }

    if (indent > 0)
    {
        while (indent > 0)
        {
            m_header->Unindent();
            m_header->writeLine(ttlib::cstr() << "} // namespace " << names[--indent]);
        }
        m_header->writeLine();
    }

    if (m_panel_type != CPP_PANEL && m_embedded_images.size())
    {
        bool is_namespace_written = false;
        for (auto iter_array: m_embedded_images)
        {
            if (iter_array->form != m_form_node)
                continue;

            if (!is_namespace_written)
            {
                m_header->writeLine();
                m_header->writeLine("namespace wxue_img\n{");

                if (form_node->isType(type_images))
                {
                    ttlib::textfile function;
                    function.ReadString(txt_wxueImageFunction);
                    for (auto& iter: function)
                    {
                        m_header->write("\t");
                        if (iter.size() && iter.at(0) == ' ')
                            m_header->write("\t");
                        m_header->writeLine(iter);
                    }
                    m_header->writeLine();
                }

                m_header->Indent();
                if (!form_node->isType(type_images))
                {
                    m_header->writeLine("// Images declared in this class module:");
                    m_header->writeLine();
                }
                is_namespace_written = true;
            }
            m_header->writeLine(ttlib::cstr("extern const unsigned char ")
                                << iter_array->array_name << '[' << (iter_array->array_size & 0xFFFFFFFF) << "];");
        }
        if (is_namespace_written)
        {
            m_header->Unindent();
            m_header->writeLine("}\n");
        }
    }
}

void BaseCodeGenerator::GenSrcEventBinding(Node* node, const EventVector& events)
{
    ASSERT_MSG(events.size(), "GenSrcEventBinding() shouldn't be called if there are no events");
    if (events.empty())
    {
        return;
    }

    auto propName = node->get_prop_ptr(prop_class_name);
    if (!propName)
    {
        FAIL_MSG(ttlib::cstr("Missing \"name\" property in ") << node->DeclName() << " class.");
        return;
    }

    auto& class_name = propName->as_string();
    if (class_name.empty())
    {
        FAIL_MSG("Property name cannot be null");
        return;
    }

    for (auto& iter: events)
    {
        if (auto generator = iter->GetNode()->GetNodeDeclaration()->GetGenerator(); generator)
        {
            Code code(node, m_language);
            auto scode = generator->GenEvents(code, iter, class_name);
#if defined(_DEBUG)
            if (is_cpp())
            {
                if (auto result = generator->GenEvents(iter, class_name); result)
                {
                }
            }
#endif  // _DEBUG

            if (scode)
            {
                if (!scode->contains("["))
                {
                    size_t indentation = scode->contains("\n") ? indent::auto_keep_whitespace : indent::auto_no_whitespace;
                    m_source->writeLine(scode.value(), indentation);
                }
                else  // this is a lambda
                {
                    if (!is_cpp())
                    {
                        m_source->writeLine("# You cannot use C++ lambda functions as an event handler in wxPython.");
                    }
                    else
                    {
                        ttlib::cstr convert(scode.value());
                        convert.Replace("@@", "\n", tt::REPLACE::all);
                        ttlib::multistr lines(convert, '\n');
                        bool initial_bracket = false;
                        for (auto& line: lines)
                        {
                            if (line.contains("}"))
                            {
                                m_source->Unindent();
                            }
                            else if (!initial_bracket && line.contains("["))
                            {
                                initial_bracket = true;
                                m_source->Indent();
                            }

                            size_t indentation = indent::auto_no_whitespace;
                            m_source->writeLine(line, indentation);

                            if (line.contains("{"))
                            {
                                m_source->Indent();
                            }
                        }
                        m_source->Unindent();
                    }
                }
            }
        }
    }
}

void BaseCodeGenerator::GenHdrEvents(const EventVector& events)
{
    ASSERT(m_language == GEN_LANG_CPLUSPLUS);

    if (events.size() || m_CtxMenuEvents.size())
    {
        std::set<ttlib::cstr> code_lines;

        for (auto& event: events)
        {
            // Ignore lambda's and functions in another class
            if (event->get_value().contains("[") || event->get_value().contains("::"))
                continue;

            ttlib::cstr code;

            // If the form has a wxContextMenuEvent node, then the handler for the form's wxEVT_CONTEXT_MENU is a method of
            // the base class and is not virtual.

            if (event->GetNode()->IsForm() && event->get_name() == "wxEVT_CONTEXT_MENU")
            {
                bool has_handler = false;

                for (const auto& child: event->GetNode()->GetChildNodePtrs())
                {
                    if (child->isGen(gen_wxContextMenuEvent))
                    {
                        has_handler = true;
                        break;
                    }
                }

                if (has_handler)
                {
                    code << "void " << event->get_value() << "(" << event->GetEventInfo()->get_event_class() << "& event);";
                    code_lines.insert(code);
                    continue;
                }
            }
            if ((event->get_name() == "wxEVT_WEBVIEW_FULL_SCREEN_CHANGED" ||
                 event->get_name() == "wxEVT_WEBVIEW_SCRIPT_MESSAGE_RECEIVED") &&
                wxGetProject().value(prop_wxWidgets_version) == "3.1")
            {
                code << "\n#if wxCHECK_VERSION(3, 1, 5)\n";
                if (m_form_node->prop_as_bool(prop_use_derived_class))
                {
                    code << "virtual void " << event->get_value() << "(" << event->GetEventInfo()->get_event_class()
                         << "& event) { event.Skip(); }";
                }
                else
                {
                    code << "void " << event->get_value() << "(" << event->GetEventInfo()->get_event_class() << "& event);";
                }
                code << "\n#endif";
            }
            else
            {
                if (m_form_node->prop_as_bool(prop_use_derived_class))
                {
                    code << "virtual void " << event->get_value() << "(" << event->GetEventInfo()->get_event_class()
                         << "& event) { event.Skip(); }";
                }
                else
                {
                    code << "void " << event->get_value() << "(" << event->GetEventInfo()->get_event_class() << "& event);";
                }
            }
            code_lines.insert(code);
        }

        // Unlike the above code, there shouldn't be any wxEVT_CONTEXT_MENU events since m_CtxMenuEvents should only contain
        // menu items events.

        for (const auto& event: m_CtxMenuEvents)
        {
            // Ignore lambda's and functions in another class
            if (event->get_value().contains("[") || event->get_value().contains("::"))
                continue;

            ttlib::cstr code;

            if (m_form_node->prop_as_bool(prop_use_derived_class))
            {
                code << "virtual void " << event->get_value() << "(" << event->GetEventInfo()->get_event_class()
                     << "& event) { event.Skip(); }";
            }
            else
            {
                code << "void " << event->get_value() << "(" << event->GetEventInfo()->get_event_class() << "& event);";
            }

            code_lines.insert(code);
        }

        if (code_lines.size())
        {
            m_header->writeLine();
            if (m_form_node->prop_as_bool(prop_use_derived_class))
            {
                m_header->writeLine("// Virtual event handlers -- override them in your derived class");
                m_header->writeLine();
            }
            else
            {
                m_header->writeLine("// Event handlers");
                m_header->writeLine();
            }
            for (auto& iter: code_lines)
            {
                m_header->writeLine(iter.subview());
            }
        }
    }
}

void BaseCodeGenerator::CollectMemberVariables(Node* node, Permission perm, std::set<std::string>& code_lines)
{
    if (auto prop = node->get_prop_ptr(prop_class_access); prop)
    {
        if (prop->as_string() != "none")
        {
            if ((perm == Permission::Public && prop->as_string() == "public:") ||
                (perm == Permission::Protected && prop->as_string() == "protected:"))
            {
                auto code = GetDeclaration(node);
                if (code.size())
                    code_lines.insert(code);
            }
        }

        if (perm == Permission::Protected)
        {
            // StaticCheckboxBoxSizer and StaticRadioBtnBoxSizer have internal variables
            if (node->HasValue(prop_checkbox_var_name) || node->HasValue(prop_radiobtn_var_name))
            {
                auto code = GetDeclaration(node);
                if (code.size())
                    code_lines.insert(code);
            }
        }

        for (const auto& child: node->GetChildNodePtrs())
        {
            CollectMemberVariables(child.get(), perm, code_lines);
        }

        return;
    }

    for (const auto& child: node->GetChildNodePtrs())
    {
        CollectMemberVariables(child.get(), perm, code_lines);
    }
}

void BaseCodeGenerator::CollectValidatorVariables(Node* node, std::set<std::string>& code_lines)
{
    GenValVarsBase(node->GetNodeDeclaration(), node, code_lines);

    for (const auto& child: node->GetChildNodePtrs())
    {
        CollectValidatorVariables(child.get(), code_lines);
    }
}

void BaseCodeGenerator::GenValidatorFunctions(Node* node)
{
    ASSERT(m_language == GEN_LANG_CPLUSPLUS);

    if (node->HasValue(prop_validator_variable))
    {
        auto result = GenGetSetCode(node);
        if (result)
        {
            m_header->writeLine(result.value());
        }
    }

    for (const auto& child: node->GetChildNodePtrs())
    {
        GenValidatorFunctions(child.get());
    }
}

void BaseCodeGenerator::GenValVarsBase(const NodeDeclaration* declaration, Node* node, std::set<std::string>& code_lines)
{
    ASSERT(m_language == GEN_LANG_CPLUSPLUS);

    if (auto& var_name = node->prop_as_string(prop_validator_variable); var_name.size())
    {
        // All validators must have a validator_data_type property, so we don't check if it exists.
        if (auto& val_data_type = node->prop_as_string(prop_validator_data_type); val_data_type.size())
        {
            ttlib::cstr code;

            if (node->HasValue(prop_platforms) && node->value(prop_platforms) != "Windows|Unix|Mac")
            {
                if (node->value(prop_platforms).contains("Windows"))
                    code << "\n#if defined(__WINDOWS__)";
                if (node->value(prop_platforms).contains("Unix"))
                {
                    if (code.size())
                        code << " || ";
                    else
                        code << "\n#if ";
                    code << "defined(__UNIX__)";
                }
                if (node->value(prop_platforms).contains("Mac"))
                {
                    if (code.size())
                        code << " || ";
                    else
                        code << "\n#if ";
                    code << "defined(__WXOSX__)";
                }
                code << "\n";
            }

            code << val_data_type << ' ' << var_name;

            if (val_data_type == "bool")
            {
                auto prop = node->get_prop_ptr(prop_checked);
                bool bState = (prop && prop->as_bool());
                if (!prop)
                {
                    prop = node->get_prop_ptr(prop_initial_state);
                    if (prop && prop->as_string() == "wxCHK_CHECKED")
                        bState = true;
                }
                code << " { " << (bState ? "true" : "false") << " };";
            }
            else if (val_data_type == "int")
            {
                auto prop = node->get_prop_ptr(prop_value);
                if (!prop)
                    prop = node->get_prop_ptr(prop_initial);
                if (!prop)
                    prop = node->get_prop_ptr(prop_selection);
                if (!prop)
                    prop = node->get_prop_ptr(prop_position);
                if (prop && prop->as_string().size())
                {
                    code << " { " << prop->as_string() << " };";
                }
                else
                {
                    code << ';';
                }
            }
            else if (val_data_type == "wxString" || val_data_type == "wxFileName")
            {
                auto& value = node->prop_as_string(prop_value);
                if (value.size())
                {
                    code << " { " << GenerateQuotedString(value) << " };";
                }
                else
                {
                    code << ';';
                }
            }
            else
            {
                code << ';';
            }

            if (node->HasValue(prop_platforms) && node->value(prop_platforms) != "Windows|Unix|Mac")
            {
                code << "\n#endif  // limited to specific platforms";
            }

            code_lines.insert(code);
        }
    }

    for (size_t i = 0; i < declaration->GetBaseClassCount(false); i++)
    {
        GenValVarsBase(declaration->GetBaseClass(i, false), node, code_lines);
    }
}

void BaseCodeGenerator::CollectIncludes(Node* node, std::set<std::string>& set_src, std::set<std::string>& set_hdr)
{
    GatherGeneratorIncludes(node, set_src, set_hdr);

    // If an include in going to be generated in the header file, then don't also generate it in the src file.
    for (auto& iter: set_hdr)
    {
        auto pos = set_src.find(iter);
        if (pos != set_src.end())
            set_src.erase(pos);
    }

    // We special-case valgen.h and valtext.h because validators are only used in the source code, but things like
    // wxRadioBox will indicate that it requires it. Note the we add these any time a control is added that might have a
    // validator -- we don't actually check to see if the validator is being used. Since this only gets included in the
    // source file, the compile time impact of including it is negligible.

    if (auto pos = set_hdr.find("#include <wx/valgen.h>"); pos != set_hdr.end())
    {
        set_hdr.erase(pos);
        set_src.insert("#include <wx/valgen.h>");
    }

    if (auto pos = set_hdr.find("#include <wx/valtext.h>"); pos != set_hdr.end())
    {
        set_hdr.erase(pos);
        set_src.insert("#include <wx/valtext.h>");
    }
}

void BaseCodeGenerator::GatherGeneratorIncludes(Node* node, std::set<std::string>& set_src, std::set<std::string>& set_hdr)
{
    if (node->isGen(gen_Images) || node->isGen(gen_folder))
    {
        return;
    }

    bool isAddToSrc = false;

    // If the component is set for local access only, then add the header file to the source set. Once all processing is
    // done, if this header was also used by a component with non-local access, then it will be removed from the source
    // set.
    if (node->isPropValue(prop_class_access, "none"))
        isAddToSrc = true;

    auto generator = node->GetNodeDeclaration()->GetGenerator();
    generator->GetIncludes(node, set_src, set_hdr);
    if (node->HasValue(prop_validator_variable))
    {
        auto& var_name = node->prop_as_string(prop_validator_variable);
        if (var_name.size())
        {
            set_hdr.insert("#include <wx/valgen.h>");
            if (node->isPropValue(prop_validator_data_type, "wxTextValidator"))
                set_hdr.insert("#include <wx/valtext.h>");
            if (node->isPropValue(prop_validator_data_type, "wxArrayInt"))
                set_hdr.insert("#include <wx/dynarray.h>");
        }
    }

    if (node->HasValue(prop_derived_header))
    {
        ttlib::cstr header("#include \"");
        header << node->prop_as_string(prop_derived_header) << '"';
        set_src.insert(header);
    }

    if (node->HasValue(prop_derived_class) && !node->isPropValue(prop_class_access, "none"))
    {
        set_hdr.insert(ttlib::cstr() << "class " << node->prop_as_string(prop_derived_class) << ';');
    }

    // A lot of widgets have wxWindow and/or wxAnyButton as derived classes, and those classes contain properties for
    // font, color, and bitmaps. If the property is used, then we add a matching header file.

    for (auto& iter: node->get_props_vector())
    {
        if (iter.HasValue())
        {
            if (iter.type() == type_wxFont)
            {
                if (isAddToSrc)
                {
                    set_src.insert("#include <wx/font.h>");
                }
                else
                {
                    set_hdr.insert("#include <wx/font.h>");
                }
            }
            else if (iter.type() == type_wxColour)
            {
                if (isAddToSrc)
                {
                    set_src.insert("#include <wx/colour.h>");
                    set_src.insert("#include <wx/settings.h>");  // This is needed for the system colours
                }
                else
                {
                    set_hdr.insert("#include <wx/colour.h>");
                    set_hdr.insert("#include <wx/settings.h>");  // This is needed for the system colours
                }
            }
            else if (iter.type() == type_image)
            {
                if (!iter.isProp(prop_icon))
                {
                    if (auto function_name = GetProject()->GetBundleFuncName(iter.as_string()); function_name.size())
                    {
                        std::vector<Node*> forms;
                        GetProject()->CollectForms(forms);

                        for (const auto& form: forms)
                        {
                            if (form->isGen(gen_Images))
                            {
                                ttlib::cstr image_file = GetProject()->getProjectPath();
                                image_file.append_filename(form->prop_as_string(prop_base_file));
                                image_file.replace_extension(m_header_ext);
                                image_file.make_relative(m_baseFullPath);
                                set_src.insert(ttlib::cstr() << "#include \"" << image_file << '\"');
                                break;
                            }
                        }
                        continue;
                    }
                }

                // The problem at this point is that we don't know how the bitmap will be used. It could be just a
                // wxBitmap, or it could be handed to a wxImage for sizing, or it might be handed to
                // wxWindow->SetIcon(). We play it safe and supply all three header files.

                if (isAddToSrc)
                {
                    set_src.insert("#include <wx/bitmap.h>");
                    set_src.insert("#include <wx/icon.h>");
                    set_src.insert("#include <wx/image.h>");
                }
                else
                {
                    set_hdr.insert("#include <wx/bitmap.h>");
                    set_hdr.insert("#include <wx/icon.h>");
                    set_hdr.insert("#include <wx/image.h>");
                }
            }
        }
    }

    // Now parse all the children
    for (const auto& child: node->GetChildNodePtrs())
    {
        GatherGeneratorIncludes(child.get(), set_src, set_hdr);
    }
}

ttlib::cstr BaseCodeGenerator::GetDeclaration(Node* node)
{
    ttlib::cstr code;
    if (node->HasValue(prop_platforms) && node->value(prop_platforms) != "Windows|Unix|Mac")
    {
        if (node->value(prop_platforms).contains("Windows"))
            code << "\n#if defined(__WINDOWS__)";
        if (node->value(prop_platforms).contains("Unix"))
        {
            if (code.size())
                code << " || ";
            else
                code << "\n#if ";
            code << "defined(__UNIX__)";
        }
        if (node->value(prop_platforms).contains("Mac"))
        {
            if (code.size())
                code << " || ";
            else
                code << "\n#if ";
            code << "defined(__WXOSX__)";
        }
        code << "\n";
    }

    ttlib::cstr class_name(node->DeclName());

    if (class_name.starts_with("wx"))
    {
        if (node->HasValue(prop_derived_class))
        {
            code << node->prop_as_string(prop_derived_class) << "* " << node->get_node_name() << ';';
        }
        else
        {
            if (node->GetGenerator()->IsGeneric(node))
            {
                class_name = node->DeclName();
                class_name.Replace("wx", "wxGeneric");
            }
            code << class_name << "* " << node->get_node_name() << ';';
        }

        if (class_name == "wxStdDialogButtonSizer")
        {
            if (node->prop_as_bool(prop_OK))
                code << "\n\twxButton* " << node->get_node_name() << "OK;";
            if (node->prop_as_bool(prop_Yes))
                code << "\n\twxButton* " << node->get_node_name() << "Yes;";
            if (node->prop_as_bool(prop_Save))
                code << "\n\twxButton* " << node->get_node_name() << "Save;";
            if (node->prop_as_bool(prop_Apply))
                code << "\n\twxButton* " << node->get_node_name() << "Apply;";
            if (node->prop_as_bool(prop_No))
                code << "\n\twxButton* " << node->get_node_name() << "No;";
            if (node->prop_as_bool(prop_Cancel))
                code << "\n\twxButton* " << node->get_node_name() << "Cancel;";
            if (node->prop_as_bool(prop_Close))
                code << "\n\twxButton* " << node->get_node_name() << "Close;";
            if (node->prop_as_bool(prop_Help))
                code << "\n\twxButton* " << node->get_node_name() << "Help;";
            if (node->prop_as_bool(prop_ContextHelp))
                code << "\n\twxButton* " << node->get_node_name() << "ContextHelp;";
        }
        else if (class_name == "wxStaticBitmap")
        {
            // If scaling was specified, then we need to switch to wxGenericStaticBitmap in order to support it.
            if (node->prop_as_string(prop_scale_mode) != "None")
                code.Replace("wxStaticBitmap", "wxGenericStaticBitmap");
        }
    }

    else if (class_name == "StaticCheckboxBoxSizer")
    {
        if (node->HasValue(prop_checkbox_var_name))
            code << "wxCheckBox* " << node->prop_as_string(prop_checkbox_var_name) << ';';

        if (!node->IsLocal())
        {
            if (code.size())
                code << "\n";
            code << "wxStaticBoxSizer* " << node->get_node_name() << ';';
        }
    }
    else if (class_name == "StaticRadioBtnBoxSizer")
    {
        if (node->HasValue(prop_radiobtn_var_name))
            code << "wxRadioButton* " << node->prop_as_string(prop_radiobtn_var_name) << ';';

        if (!node->IsLocal())
        {
            if (code.size())
                code << "\n";
            code << "wxStaticBoxSizer* " << node->get_node_name() << ';';
        }
    }

    else if (class_name == "propGridItem")
    {
        code << "wxPGProperty* " << node->get_node_name() << ';';
    }
    else if (class_name == "BookPage")
    {
        code << "wxPanel* " << node->get_node_name() << ';';
    }
    else if (class_name == "propGridPage")
    {
        code << "wxPropertyGridPage* " << node->get_node_name() << ';';
    }
    else if (class_name == "submenu")
    {
        code << "wxMenu* " << node->get_node_name() << ';';
    }
    else if (class_name == "Check3State")
    {
        code << "wxCheckBox* " << node->get_node_name() << ';';
    }
    else if (class_name == "tool")
    {
        class_name = node->GetParent()->DeclName();
        if (class_name == "wxAuiToolBar")
        {
            code << "wxAuiToolBarItem* " << node->get_node_name() << ';';
        }
        else if (class_name == "wxToolBar")
        {
            code << "wxToolBarToolBase* " << node->get_node_name() << ';';
        }
        else if (class_name == "ToolBar")
        {
            code << "wxToolBarToolBase* " << node->get_node_name() << ';';
        }
        else
        {
            FAIL_MSG("Unrecognized class name so no idea how to declare it in the header file.")
        }
    }
    else if (class_name.is_sameas("CustomControl"))
    {
        if (auto* node_namespace = node->get_folder(); node_namespace && node_namespace->HasValue(prop_folder_namespace))
        {
            code << node_namespace->as_string(prop_folder_namespace) << "::";
        }
        else if (node->HasValue(prop_namespace))
        {
            code << node->prop_as_string(prop_namespace) << "::";
        }
        code << node->prop_as_string(prop_class_name) << "* " << node->get_node_name() << ';';
    }

    if (node->HasValue(prop_var_comment))
    {
        code << "  // " << node->prop_as_string(prop_var_comment);
    }

    if (node->HasValue(prop_platforms) && node->value(prop_platforms) != "Windows|Unix|Mac")
    {
        code << "\n#endif  // limited to specific platforms";
    }

    return code;
}

void BaseCodeGenerator::GenerateClassHeader(Node* form_node, const EventVector& events)
{
    ASSERT(m_language == GEN_LANG_CPLUSPLUS);

    if (form_node->isType(type_images))
    {
        // The Images form is not a class
        return;
    }

    if (!form_node->HasValue(prop_class_name))
    {
        FAIL_MSG(ttlib::cstr("Missing \"name\" property in ") << form_node->DeclName());
        return;
    }

    auto generator = form_node->GetNodeDeclaration()->GetGenerator();

    // This may result in two blank lines, but without it there may be a case where there is no blank line at all.
    // Clang-format, if enabled would remove the extra blank line, but would not add the missing blank line.
    m_header->writeLine();

    Code code(form_node, GEN_LANG_CPLUSPLUS);
    code.Str("class ");
    if (form_node->HasValue(prop_class_decoration))
        code.Str(prop_class_decoration) += " ";
    code.Str(prop_class_name) += " : public ";
    if (generator->CodeAdditionalCode(code, code_base_class))
    {
        m_header->writeLine(code.GetCode(), indent::auto_keep_whitespace);
    }
    else if (auto result = generator->GenAdditionalCode(code_base_class, form_node); result)
    {
        code += result.value();
        m_header->writeLine(code.GetCode());
    }
    else
    {
        FAIL_MSG("All form generators need to support code_base_class command to provide the class name to derive from.");

        // The only way this would be valid is if the base class didn't derive from anything.
        m_header->writeLine(ttlib::cstr() << "class " << form_node->prop_as_string(prop_class_name));
    }

    m_header->writeLine("{");
    m_header->writeLine("public:");
    m_header->Indent();
    m_header->SetLastLineBlank();

    // The set is used to prevent duplicates and to write the lines sorted. Call WriteSetLines() to write the lines and
    // clear the set.
    std::set<std::string> code_lines;
    CollectMemberVariables(form_node, Permission::Public, code_lines);
    if (code_lines.size())
    {
        WriteSetLines(m_header, code_lines);
        m_header->writeLine();
    }

    code.clear();
    if (generator->CodeAdditionalCode(code, code_header))
    {
        m_header->writeLine(code.GetCode(), indent::auto_keep_whitespace);
    }

    else if (auto result = generator->GenAdditionalCode(code_header, form_node); result)
    {
        m_header->writeLine(result.value(), indent::auto_keep_whitespace);
    }
    m_header->SetLastLineBlank();

    GenValidatorFunctions(form_node);
    m_header->writeLine();

    GenEnumIds(form_node);

    if (m_form_node->HasValue(prop_inserted_hdr_code))
    {
        WritePropHdrCode(m_form_node, prop_inserted_hdr_code);
    }

    m_header->Unindent();
    m_header->writeLine("protected:");
    m_header->Indent();

    GenHdrEvents(events);

    if (!m_form_node->prop_as_bool(prop_use_derived_class) && form_node->prop_as_bool(prop_private_members))
    {
        m_header->Unindent();
        m_header->writeLine();
        m_header->writeLine("private:");
        m_header->Indent();
    }

    CollectValidatorVariables(form_node, code_lines);
    if (code_lines.size())
    {
        m_header->writeLine();
        m_header->writeLine("// Validator variables");
        m_header->writeLine();
        WriteSetLines(m_header, code_lines);
    }

    CollectMemberVariables(form_node, Permission::Protected, code_lines);
    if (code_lines.size())
    {
        m_header->writeLine();
        m_header->writeLine("// Class member variables");
        m_header->writeLine();
        WriteSetLines(m_header, code_lines);
    }

    m_header->Unindent();
    m_header->writeLine("};");
}

void BaseCodeGenerator::GenEnumIds(Node* class_node)
{
    ASSERT(m_language == GEN_LANG_CPLUSPLUS);

    if (!class_node->prop_as_bool(prop_generate_ids))
        return;

    std::set<std::string> set_ids;
    CollectIDs(class_node, set_ids);
    if (set_ids.empty())
        return;

    m_header->writeLine("enum");
    m_header->writeLine("{");
    m_header->Indent();

    size_t item = 0;
    for (auto& iter: set_ids)
    {
        m_header->write(iter);
        if (item == 0)
        {
            m_header->write(" = wxID_HIGHEST + 1", true);
        }

        if (item < set_ids.size() - 1)
        {
            m_header->writeLine(",");
        }
        ++item;
    }

    m_header->Unindent();
    m_header->writeLine();
    m_header->writeLine("};");
    m_header->writeLine();
}

void BaseCodeGenerator::GenerateClassConstructor(Node* form_node, const EventVector& events)
{
    ASSERT(m_language == GEN_LANG_CPLUSPLUS);

    m_source->writeLine();

    auto* generator = form_node->GetGenerator();
    Code code(form_node, GEN_LANG_CPLUSPLUS);
    if (generator->CodeConstruction(code))
    {
        m_source->writeLine(code.GetCode(), indent::auto_keep_whitespace);
        m_source->Indent();

        if (form_node->isGen(gen_wxFrame))
        {
            GenerateHandlers();
        }

        code.clear();
        if (generator->CodeSettings(code))
        {
            m_source->writeLine(code.GetCode());
            m_source->writeLine();
        }
        else
        {
            size_t auto_indent = indent::auto_no_whitespace;
            if (auto result = generator->GenSettings(form_node, auto_indent); result)
            {
                if (result.value().size())
                {
                    m_source->writeLine(result.value(), indent::auto_keep_whitespace);
                    m_source->writeLine();
                }
            }
        }
    }
    else if (!generator->GenConstruction(form_node, this))
    {
        if (auto result = generator->GenConstruction(form_node); result)
        {
            m_source->writeLine(result.value(), indent::none);
            m_source->Indent();
        }

        if (form_node->isGen(gen_wxFrame))
        {
            GenerateHandlers();
        }

        size_t auto_indent = indent::auto_no_whitespace;
        if (auto result = generator->GenSettings(form_node, auto_indent); result)
        {
            if (result.value().size())
            {
                m_source->writeLine(result.value(), indent::auto_keep_whitespace);
                m_source->writeLine();
            }
        }
    }
    else
    {
        m_source->Indent();
    }

    if (!form_node->isGen(gen_wxWizard) && !form_node->isGen(gen_wxFrame))
    {
        GenerateHandlers();
    }

    if (form_node->get_prop_ptr(prop_window_extra_style))
    {
        code.clear();
        code.GenWindowSettings();
        if (code.size())
        {
            // GenerateWindowSettings() can result in code within braces, so keep any leading whitespace.
            m_source->writeLine(code.m_code, indent::auto_keep_whitespace);
        }
    }

    m_source->SetLastLineBlank();
    for (const auto& child: form_node->GetChildNodePtrs())
    {
        if (child->isGen(gen_wxContextMenuEvent))
            continue;
        GenConstruction(child.get());
    }

    code.clear();
    if (generator->CodeAdditionalCode(code, code_after_children))
    {
        if (code.size())
        {
            m_source->writeLine();
            m_source->writeLine(code.GetCode(), indent::auto_keep_whitespace);
        }
    }
    else if (auto result = generator->GenAdditionalCode(code_after_children, form_node); result)
    {
        if (result.value().size())
        {
            m_source->writeLine();
            m_source->writeLine(result.value(), indent::none);
        }
    }

    if (form_node->prop_as_bool(prop_persist))
    {
        m_source->writeLine();
        ttlib::cstr tmp("wxPersistentRegisterAndRestore(this, \"");
        tmp << form_node->get_node_name() << "\");";
        m_source->writeLine(tmp);
    }

    AddPersistCode(form_node);

    if (events.size())
    {
        m_source->writeLine();
        m_source->writeLine("// Event handlers");
        GenSrcEventBinding(form_node, events);
    }

    if (form_node->isGen(gen_wxDialog) || form_node->isGen(gen_PanelForm))
    {
        m_source->writeLine("\nreturn true;");
    }

    m_source->Unindent();
    m_source->writeLine("}");

    Node* node_ctx_menu = nullptr;
    for (const auto& child: form_node->GetChildNodePtrs())
    {
        if (child->isGen(gen_wxContextMenuEvent))
        {
            node_ctx_menu = child.get();
            break;
        }
    }

    if (node_ctx_menu)
        GenContextMenuHandler(form_node, node_ctx_menu);
}

void BaseCodeGenerator::CollectIDs(Node* node, std::set<std::string>& set_ids)
{
    for (auto& iter: node->get_props_vector())
    {
        if (iter.type() == type_id)
        {
            auto& prop_id = iter.as_string();
            if (prop_id.size() && !prop_id.starts_with("wxID_"))
                set_ids.insert(prop_id);
        }
    }

    for (const auto& iter: node->GetChildNodePtrs())
    {
        CollectIDs(iter.get(), set_ids);
    }
}

void BaseCodeGenerator::CollectEventHandlers(Node* node, EventVector& events)
{
    ASSERT(node);
    for (auto& iter: node->GetMapEvents())
    {
        if (iter.second.get_value().size())
        {
            events.push_back(&iter.second);
        }
    }

    for (const auto& child: node->GetChildNodePtrs())
    {
        if (child->isGen(gen_wxContextMenuEvent))
        {
            for (const auto& ctx_child: child->GetChildNodePtrs())
            {
                CollectEventHandlers(ctx_child.get(), m_CtxMenuEvents);
            }
            continue;
        }
        CollectEventHandlers(child.get(), events);
    }
}

// This function is called by the thread thrd_collect_img_headers
void BaseCodeGenerator::CollectImageHeaders(Node* node, std::set<std::string>& embedset)
{
    for (auto& iter: node->get_props_vector())
    {
        if (!iter.HasValue())
            continue;

        auto& value = iter.as_string();
        if (iter.type() == type_image)
        {
            if (auto bundle = GetProject()->GetPropertyImageBundle(iter.as_string()); bundle)
            {
                if (value.starts_with("Embed") || value.starts_with("SVG"))
                {
                    for (auto& idx_image: bundle->lst_filenames)
                    {
                        if (auto embed = GetProject()->GetEmbeddedImage(idx_image); embed)
                        {
                            bool is_found = false;
                            for (auto pimage: m_embedded_images)
                            {
                                if (pimage == embed)
                                {
                                    is_found = true;
                                    break;
                                }
                            }
                            if (!is_found)
                            {
                                m_embedded_images.emplace_back(embed);
                            }
                        }
                    }
                }
                else if (value.starts_with("Header") || value.starts_with("XPM"))
                {
                    for (auto& idx_image: bundle->lst_filenames)
                    {
                        ttlib::cstr path(idx_image);
                        path.backslashestoforward();
                        embedset.insert(ttlib::cstr() << "#include \"" << path << "\"");
                    }
                }
            }
            else
            {
                // Since this is a thread, you can't send the standard MSG_WARNING if the window is opened, or it will lock
                // the debugger.
            }
        }

        else if (iter.type() == type_animation)
        {
            if (value.starts_with("Embed"))
            {
                ttlib::multiview parts(value, BMP_PROP_SEPARATOR, tt::TRIM::both);

                if (parts[IndexImage].size())
                {
                    auto embed = GetProject()->GetEmbeddedImage(parts[IndexImage]);
                    if (!embed)
                    {
                        if (!GetProject()->AddEmbeddedImage(parts[IndexImage], m_form_node))
                            continue;
                        embed = GetProject()->GetEmbeddedImage(parts[IndexImage]);
                        if (!embed)
                            continue;
                    }
                    else
                    {
                        bool is_found = false;
                        for (auto& pimage: m_embedded_images)
                        {
                            if (pimage == embed)
                            {
                                is_found = true;
                                break;
                            }
                        }
                        if (is_found)
                            continue;  // we already have this image
                    }

                    m_embedded_images.emplace_back(embed);
                }
            }
            else if (value.starts_with("Header") || value.starts_with("XPM"))
            {
                ttlib::multiview parts(value);
                if (ttlib::is_whitespace(parts[IndexImage].front()))
                {
                    parts[IndexImage].remove_prefix(1);
                }
                ttlib::cstr path = parts[IndexImage];
                path.make_relative(m_baseFullPath);
                path.backslashestoforward();
                ttlib::cstr inc;
                inc << "#include \"" << path << "\"";
                embedset.insert(inc);
            }
        }
    }

    for (auto& child: node->GetChildNodePtrs())
    {
        CollectImageHeaders(child.get(), embedset);
    }
}

// Called by the thread thrd_need_img_func
//
// Determine if Header or Animation functions need to be generated, and whether the
// wx/artprov.h header is needed
void BaseCodeGenerator::ParseImageProperties(Node* node)
{
    ASSERT(node);
    if (node->IsForm() && node->HasValue(prop_icon))
    {
        ttlib::multiview parts(node->prop_as_string(prop_icon), BMP_PROP_SEPARATOR, tt::TRIM::both);
        if (parts.size() >= IndexImage + 1)
        {
            if (parts[IndexType] == "Header")
            {
                m_NeedHeaderFunction = true;
            }
            else if (parts[IndexType] == "Embed")
            {
                m_NeedImageFunction = true;
            }
            else if ((parts[IndexType] == "Art"))
            {
                m_NeedArtProviderHeader = true;
            }
            else if ((parts[IndexType] == "SVG"))
            {
                m_NeedSVGFunction = true;
            }
        }
    }

    for (const auto& child: node->GetChildNodePtrs())
    {
        for (auto& iter: child->get_props_vector())
        {
            if ((iter.type() == type_image || iter.type() == type_animation) && iter.HasValue())
            {
                ttlib::multistr parts(iter.as_string(), BMP_PROP_SEPARATOR, tt::TRIM::both);
                if (parts.size() < IndexImage + 1)
                    continue;

                // If the is a Images form, then we need to see if the image property refers to an image within the Images
                // form. If so, a function call will be made to the Image Form's source code to load the image and therefore
                // we don't need to generate and special header files or generate the general purpose image loading function.

                if (m_ImagesForm && m_form_node != m_ImagesForm)
                {
                    if (auto bundle = GetProject()->GetPropertyImageBundle(parts); bundle && bundle->lst_filenames.size())
                    {
                        if (auto embed = GetProject()->GetEmbeddedImage(bundle->lst_filenames[0]); embed)
                        {
                            if (embed->form == m_ImagesForm)
                            {
                                continue;
                            }
                        }
                    }
                }

                if (parts[IndexType] == "Embed")
                {
                    if (iter.type() == type_animation)
                        m_NeedAnimationFunction = true;
                    else
                        m_NeedImageFunction = true;
                }
                else if ((parts[IndexType] == "Art"))
                {
                    m_NeedArtProviderHeader = true;
                }
                else if ((parts[IndexType] == "SVG"))
                {
                    m_NeedSVGFunction = true;
                }
                else if (parts[IndexType] == "Header")
                {
                    if (iter.type() == type_animation)
                        m_NeedAnimationFunction = true;
                    else if (!ttlib::is_sameas(parts[IndexImage].extension(), ".xpm", tt::CASE::either))
                        m_NeedHeaderFunction = true;
                }
            }
        }
        if (child->GetChildCount())
        {
            ParseImageProperties(child.get());
        }
    }
}

void BaseCodeGenerator::AddPersistCode(Node* node)
{
    if (node->HasValue(prop_persist_name))
    {
        ttlib::cstr code("wxPersistentRegisterAndRestore(");
        code << node->get_node_name() << ", \"" << node->prop_as_string(prop_persist_name) << "\");";
        m_source->writeLine(code);
    }

    for (const auto& child: node->GetChildNodePtrs())
    {
        AddPersistCode(child.get());
    }
}

void BaseCodeGenerator::WriteSetLines(WriteCode* out, std::set<std::string>& code_lines)
{
    for (auto iter: code_lines)
    {
        // out->writeLine((ttlib::cstr&) (iter));
        out->writeLine(iter);
    }
    code_lines.clear();
}

void BaseCodeGenerator::GenContextMenuHandler(Node* form_node, Node* node_ctx_menu)
{
    ASSERT(m_language == GEN_LANG_CPLUSPLUS);

    m_source->writeLine();

    m_source->writeLine(ttlib::cstr() << "void " << form_node->get_node_name()
                                      << "::" << node_ctx_menu->prop_as_string(prop_handler_name)
                                      << "(wxContextMenuEvent& event)\n{");

    m_source->Indent();
    m_source->writeLine("wxMenu menu;");
    m_source->writeLine("auto pmenu = &menu;  // convenience variable for the auto-generated code");

    // All of the constructors are expecting a wxMenu parent -- so we need to temporarily create one
    auto node_menu = g_NodeCreator.NewNode(g_NodeCreator.GetNodeDeclaration("wxMenu"));
    node_menu->prop_set_value(prop_var_name, "pmenu");

    for (const auto& child: node_ctx_menu->GetChildNodePtrs())
    {
        auto child_node = g_NodeCreator.MakeCopy(child);
        node_menu->Adopt(child_node);
        GenCtxConstruction(child_node.get());
    }
    m_source->writeLine();

    for (auto& iter: m_CtxMenuEvents)
    {
        if (auto generator = iter->GetNode()->GetNodeDeclaration()->GetGenerator(); generator)
        {
            Code code(form_node, m_language);
            if (auto result = generator->GenEvents(code, iter, form_node->get_node_name()); result)
            {
                m_source->write("menu.");
                m_source->writeLine(result.value(), result.value().contains("\n") ? indent::auto_keep_whitespace :
                                                                                    indent::auto_no_whitespace);
            }
        }
    }
    m_source->writeLine();

    // Using event.GetObject() instead of this means that the handler isn't limited to just the form base class.
    m_source->writeLine("wxStaticCast(event.GetEventObject(), wxWindow)->PopupMenu(&menu);");
    m_source->Unindent();
    m_source->writeLine("}");
}

void BaseCodeGenerator::GenCtxConstruction(Node* node)
{
    std::optional<ttlib::sview> scode;
    std::optional<ttlib::cstr> result;

    if (auto generator = node->GetNodeDeclaration()->GetGenerator(); generator)
    {
        Code gen_code(node, m_language);
        scode = generator->CommonConstruction(gen_code);
        if (!scode && is_cpp())
        {
            if (result = generator->GenConstruction(node); result)
                scode = *result;
        }
        if (scode && scode->size())
        {
            if (!node->isGen(gen_wxMenuItem))
                m_source->writeLine();
            m_source->writeLine(scode.value(), indent::auto_keep_whitespace);
        }

        gen_code.clear();
        scode = generator->CommonSettings(gen_code);
        if (!scode && is_cpp())
        {
            size_t auto_indent = indent::auto_keep_whitespace;
            if (result = generator->GenSettings(node, auto_indent); result)
                scode = *result;
        }
        if (scode && scode->size())
        {
            if (!node->isGen(gen_wxMenuItem))
                m_source->writeLine();
            m_source->writeLine(scode.value(), indent::auto_keep_whitespace);
        }

        for (const auto& child: node->GetChildNodePtrs())
        {
            GenCtxConstruction(child.get());
        }

        if (node->isGen(gen_submenu))
        {
            gen_code.clear();
            scode = generator->CommonAdditionalCode(gen_code, code_after_children);
            if (!scode && is_cpp())
            {
                if (result = generator->GenAdditionalCode(code_after_children, node); result)
                    scode = *result;
            }
            if (scode && scode->size())
            {
                if (!node->isGen(gen_wxMenuItem))
                    m_source->writeLine();
                m_source->writeLine(scode.value(), indent::auto_keep_whitespace);
            }
        }
        m_source->writeLine();
    }
}

void BaseCodeGenerator::GenerateHandlers()
{
    ASSERT(m_language == GEN_LANG_CPLUSPLUS);

    if (m_embedded_images.size())
    {
        for (auto& iter_img: m_embedded_images)
        {
            // wxBITMAP_TYPE_INVALID means it is a zlib compressed SVG string
            if (iter_img->type != wxBITMAP_TYPE_BMP && iter_img->type != wxBITMAP_TYPE_INVALID &&
                m_type_generated.find(iter_img->type) == m_type_generated.end())
            {
                m_source->writeLine(ttlib::cstr("if (!wxImage::FindHandler(") << g_map_types[iter_img->type] << "))");
                m_source->Indent();
                m_source->writeLine(ttlib::cstr("\twxImage::AddHandler(new ") << g_map_handlers[iter_img->type] << ");");
                m_source->Unindent();
                m_type_generated.insert(iter_img->type);
            }
        }
        m_source->writeLine();
    }
}

void BaseCodeGenerator::WritePropSourceCode(Node* node, GenEnum::PropName prop)
{
    ttlib::cstr convert(node->prop_as_string(prop));
    convert.Replace("@@", "\n", tt::REPLACE::all);
    ttlib::multistr lines(convert, '\n');
    bool initial_bracket = false;
    for (auto& code: lines)
    {
        if (code.contains("}"))
        {
            m_source->Unindent();
        }
        else if (!initial_bracket && code.contains("["))
        {
            initial_bracket = true;
            m_source->Indent();
        }

        m_source->writeLine(code, indent::auto_no_whitespace);

        if (code.contains("{"))
        {
            m_source->Indent();
        }
    }
    m_source->Unindent();
    m_source->writeLine();
}

void BaseCodeGenerator::WritePropHdrCode(Node* node, GenEnum::PropName prop)
{
    ttlib::cstr convert(node->prop_as_string(prop));
    convert.Replace("@@", "\n", tt::REPLACE::all);
    ttlib::multistr lines(convert, '\n', tt::TRIM::right);
    bool initial_bracket = false;
    for (auto& code: lines)
    {
        if (code.contains("}") && !code.contains("{"))
        {
            m_header->Unindent();
        }
        else if (!initial_bracket && code.contains("["))
        {
            initial_bracket = true;
            m_header->Indent();
        }

        if (code.is_sameas("public:") || code.is_sameas("protected:") || code.is_sameas("private:"))
        {
            m_header->Unindent();
            m_header->writeLine(code, indent::auto_no_whitespace);
            m_header->Indent();
        }
        else
        {
            m_header->writeLine(code, indent::auto_no_whitespace);
        }

        if (code.contains("{") && !code.contains("}"))
        {
            m_header->Indent();
        }
    }
    m_header->Unindent();
    m_header->writeLine();
}
