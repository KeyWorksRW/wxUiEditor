/////////////////////////////////////////////////////////////////////////////
// Purpose:   Generate Ruby code files
// Author:    Ralph Walden
// Copyright: Copyright (c) 2023-2025 KeyWorks Software (Ralph Walden)
// License:   Apache License -- see ../../LICENSE
/////////////////////////////////////////////////////////////////////////////

#include <wx/artprov.h>

#include <algorithm>
#include <set>
#include <thread>

#include "gen_ruby.h"
#include "gen_script_common.h"  // Common functions for generating Script Languages

#include "base_generator.h"   // BaseGenerator -- Base widget generator class
#include "code.h"             // Code -- Helper class for generating code
#include "common_strings.h"   // Common strings used in code generation
#include "file_codewriter.h"  // FileCodeWriter -- Classs to write code to disk
#include "gen_common.h"       // Common component functions
#include "gen_timer.h"        // TimerGenerator class
#include "image_gen.h"        // Functions for generating embedded images
#include "image_handler.h"    // ImageHandler class
#include "node.h"             // Node class
#include "project_handler.h"  // ProjectHandler class
#include "tt_view_vector.h"   // tt_view_vector -- Read/Write line-oriented strings/files
#include "utils.h"            // Miscellaneous utilities
#include "write_code.h"       // Write code to Scintilla or file

#include "../customprops/eventhandler_dlg.h"  // EventHandlerDlg static functions

using namespace code;
using namespace GenEnum;

// clang-format off

inline constexpr const auto txt_PoundCmtBlock =
R"===(###############################################################################
# Code generated by wxUiEditor -- see https://github.com/KeyWorksRW/wxUiEditor/
#
# Do not edit any code above the "End of generated code" comment block.
# Any changes before that block will be lost if it is re-generated!
###############################################################################

)===";

inline constexpr const auto txt_ruby_get_bundle =
R"===(
# Loads image(s) from a string and returns a Wx::BitmapBundle object.
def wxue_get_bundle(image_name1, image_name2 = nil, image_name3 = nil)
  image1 = Wx::Image.new
  image1.load_stream(StringIO.new(image_name1))
  if (image_name2)
    image2 = Wx::Image.new
    image2.load_stream(StringIO.new(image_name2))
    if (image_name3)
      image3 = Wx::Image.new
      image3.load_stream(StringIO.new(image_name3))
      bitmaps = [Wx::Bitmap.new(image1),
                 Wx::Bitmap.new(image2),
                 Wx::Bitmap.new(image3)]
      bundle = Wx::BitmapBundle.from_bitmaps(bitmaps)
      return bundle
    else
      bundle = Wx::BitmapBundle.from_bitmaps(Wx::Bitmap.new(image1),
                                             Wx::Bitmap.new(image2))
      return bundle
    end
  end
  bundle = Wx::BitmapBundle.from_image(image1)
  return bundle
end
)===";

inline constexpr const auto txt_ruby_get_animation =
R"===(
# Loads image from a string and returns a Wx::Animation object.
def get_animation(image_name)
  animation = Wx::Animation.new
  animation.load(StringIO.new(image_name))
  return animation
end
)===";

// clang-format on

#if defined(_DEBUG)
// clang-format off
static const std::vector<tt_string> disable_list = {
    "Metrics/MethodLength",
    "Metrics/ParameterLists",
    "Style/Documentation",
    "Style/BlockComments",
    "Metrics/AbcSize",
};
// clang-format on
#endif  // _DEBUG

RubyCodeGenerator::RubyCodeGenerator(Node* form_node) : BaseCodeGenerator(GEN_LANG_RUBY, form_node)
{
}

auto RubyCodeGenerator::InitializeThreads(std::set<std::string>& img_include_set)
    -> std::tuple<std::thread, std::thread, std::thread>
{
    auto thrd_get_events = std::thread(&RubyCodeGenerator::CollectEventHandlers, this, m_form_node,
                                       std::ref(m_events));
    auto thrd_need_img_func =
        std::thread(&RubyCodeGenerator::ParseImageProperties, this, m_form_node);
    auto thrd_collect_img_headers = std::thread(&RubyCodeGenerator::CollectImageHeaders, this,
                                                m_form_node, std::ref(img_include_set));

    return { std::move(thrd_get_events), std::move(thrd_need_img_func),
             std::move(thrd_collect_img_headers) };
}

auto RubyCodeGenerator::WriteSourceHeader() -> void
{
#if !defined(_DEBUG)
    if (m_panel_type == NOT_PANEL)
#else
    if (m_panel_type != NOT_PANEL)
    {
        m_source->writeLine("# The following comment block is only displayed in a _DEBUG build, or "
                            "when written to a file.\n\n");
    }
#endif  // _DEBUG
    {
        m_source->writeLine(txt_PoundCmtBlock);

        if (Project.as_bool(prop_disable_rubo_cop))
        {
#if defined(_DEBUG)
            for (const auto& iter: disable_list)
            {
                m_source->writeLine("# rubocop:disable " + iter);
            }
#else
            m_source->writeLine("# rubocop:disable all");
#endif
            m_source->writeLine();
        }

        if (Project.HasValue(prop_ruby_project_preamble))
        {
            WritePropSourceCode(Project.get_ProjectNode(), prop_ruby_project_preamble);
        }
    }

    m_source->writeLine(
        "WX_GLOBAL_CONSTANTS = true unless defined? WX_GLOBAL_CONSTANTS\n\nrequire 'wx/core'");
}

auto RubyCodeGenerator::WriteImports(std::set<std::string>& imports) -> void
{
    auto GatherImportModules = [&](Node* node, auto&& GatherImportModules) -> void
    {
        if (auto* gen = node->get_Generator(); gen)
        {
            gen->GetImports(node, imports, GEN_LANG_RUBY);
        }
        for (auto& child: node->get_ChildNodePtrs())
        {
            GatherImportModules(child.get(), GatherImportModules);
        }
    };
    GatherImportModules(m_form_node, GatherImportModules);

    for (const auto& import: imports)
    {
        m_source->writeLine(import);
        m_header->writeLine(import);
    }
    m_source->writeLine();
    m_header->writeLine();
}

auto RubyCodeGenerator::WriteRelativeRequires(const std::vector<Node*>& forms) -> void
{
    if (m_form_node->HasValue(prop_relative_require_list))
    {
        tt_string_vector list;
        list.SetString(m_form_node->as_string(prop_relative_require_list));
        for (auto& iter: list)
        {
            iter.remove_extension();
            m_source->writeLine(tt_string("require_relative '") << iter << '\'');
        }
        if (list.size())
        {
            m_source->writeLine();
        }
    }

    if (m_form_node->is_Type(type_frame_form) && m_form_node->as_bool(prop_import_all_dialogs))
    {
        for (const auto& form: forms)
        {
            if ((form->is_Gen(gen_wxDialog) || form->is_Gen(gen_wxWizard)) &&
                form->HasValue(prop_ruby_file))
            {
                tt_string import_name(form->as_string(prop_ruby_file).filename());
                import_name.remove_extension();
                m_source->writeLine(tt_string("require_relative '") << import_name << "'");
            }
        }
    }
}

auto RubyCodeGenerator::WriteIDConstants() -> void
{
    int id_value = wxID_HIGHEST;
    for (const auto& iter: m_set_enum_ids)
    {
        m_source->writeLine(tt_string() << '$' << iter << " = " << id_value++);
    }
    for (const auto& iter: m_set_const_ids)
    {
        if (tt::contains(iter, " wx"))
        {
            wxString wx_id = '$' + iter;
            wx_id.Replace(" wx", " Wx::", true);
            m_source->writeLine(wx_id.ToStdString());
        }
        else
        {
            m_source->writeLine('$' + iter);
        }
    }
}

auto RubyCodeGenerator::WriteInheritedClass() -> void
{
    tt_string inherit_name = m_form_node->as_string(prop_ruby_inherit_name);
    if (inherit_name.empty())
    {
        inherit_name += "Sample < " + m_form_node->as_string(prop_class_name);
    }
    if (inherit_name.size())
    {
        tt_string inherit("class ");
        inherit << inherit_name;
        inherit << m_form_node->as_string(prop_ruby_file) << "."
                << m_form_node->as_string(prop_class_name) << "):";

        m_header->writeLine(inherit);
        m_header->Indent();
        m_header->writeLine("def initialize(parent)");
        m_header->writeLine("end");
        m_header->Unindent();
        m_header->writeLine();
    }
}

auto RubyCodeGenerator::GenerateConstructionCode(Code& code) -> void
{
    auto* generator = m_form_node->get_NodeDeclaration()->get_Generator();
    code.clear();
    if (generator->ConstructionCode(code))
    {
        m_source->writeLine(code);
        m_source->writeLine();
        m_source->Indent();
        m_source->Indent();
    }

    code.clear();
    if (generator->SettingsCode(code))
    {
        if (code.size())
        {
            m_source->writeLine(code);
            m_source->writeLine();
        }
    }

    if (m_form_node->get_PropPtr(prop_window_extra_style))
    {
        code.clear();
        code.GenWindowSettings();
        if (code.size())
        {
            m_source->writeLine(code);
        }
    }

    m_source->SetLastLineBlank();
    for (const auto& child: m_form_node->get_ChildNodePtrs())
    {
        if (child->is_Gen(gen_wxContextMenuEvent))
        {
            continue;
        }
        GenConstruction(child.get());
    }

    code.clear();
    if (generator->AfterChildrenCode(code))
    {
        if (code.size())
        {
            m_source->writeLine();
            m_source->writeLine(code);
        }
    }

    if (m_form_node->as_bool(prop_persist))
    {
        m_source->writeLine();
        tt_string tmp("Wx.persistent_register_and_restore(self, \"");
        tmp << m_form_node->get_NodeName() << "\");";
        m_source->writeLine(tmp);
    }

    auto rlambda = [&](Node* node, auto&& rlambda) -> void
    {
        if (node->HasValue(prop_persist_name))
        {
            tt_string code("Wx.persistent_register_and_restore(");
            code << node->get_NodeName() << ", \"" << node->as_string(prop_persist_name) << "\");";
            m_source->writeLine(code);
        }

        for (const auto& child: node->get_ChildNodePtrs())
        {
            rlambda(child.get(), rlambda);
        }
    };

    rlambda(m_form_node, rlambda);

    code.clear();
    if (TimerGenerator::StartIfChildTimer(m_form_node, code))
    {
        m_source->writeLine(code);
        m_source->writeLine();
    }
}

auto RubyCodeGenerator::GenerateEventHandlers([[maybe_unused]] Code& code,
                                              std::thread& thrd_get_events) -> void
{
    thrd_get_events.join();
    if (m_events.size())
    {
        m_source->writeLine();
        m_source->writeLine("# Event handlers");
        GenSrcEventBinding(m_form_node, m_events);

        m_source->writeLine("\tend", indent::none);
        m_source->SetLastLineBlank();

        m_source->ResetIndent();
        m_source->writeLine();
        m_source->Indent();
        GenUnhandledEvents(m_events);
    }
    else
    {
        m_source->ResetIndent();
        m_source->writeLine("\tend", indent::none);
    }
    m_header->ResetIndent();
    m_header->writeLine("end", indent::none);
}

auto RubyCodeGenerator::WriteHelperFunctions() -> void
{
    if (m_NeedImageFunction)
    {
        m_source->doWrite("\n");  // force an extra line break
        m_source->writeLine(txt_ruby_get_bundle, indent::auto_keep_whitespace);
    }

    if (m_NeedAnimationFunction)
    {
        if (!m_NeedImageFunction)
        {
            m_source->doWrite("\n");  // force an extra line break
        }
        m_source->writeLine(txt_ruby_get_animation, indent::auto_keep_whitespace);
    }
}

auto RubyCodeGenerator::WriteEmbeddedImages(Code& code) -> void
{
    code.clear();
    // Now write any embedded images that aren't declared in the gen_Images List
    for (auto& iter: m_embedded_images)
    {
        // Only write the images that aren't declared in any gen_Images List. Note that
        // this *WILL* result in duplicate images being written to different forms.
        if (iter->get_Form() != m_ImagesForm)
        {
            WriteImageConstruction(code);
            m_source->doWrite("\n");  // force an extra line break
            m_source->SetLastLineBlank();
            break;
        }
    }
}

auto RubyCodeGenerator::WriteRuboCopFooter() -> void
{
#if !defined(_DEBUG)
    if (m_panel_type == NOT_PANEL)
#endif  // _DEBUG
    {
        if (Project.as_bool(prop_disable_rubo_cop))
        {
            m_source->writeLine();
#if defined(_DEBUG)
            for (const auto& iter: disable_list)
            {
                m_source->writeLine("# rubocop:enable " + iter);
            }
#else
            m_source->writeLine("# rubocop:enable all");
#endif  // _DEBUG
            m_source->writeLine();
        }
    }
}

void RubyCodeGenerator::GenerateClass(GenLang language, PANEL_PAGE panel_type)
{
    m_language = language;
    m_panel_type = panel_type;
    ASSERT(m_language == GEN_LANG_RUBY);
    Code code(m_form_node, m_language);

    m_embedded_images.clear();
    m_NeedAnimationFunction = false;
    m_NeedImageFunction = false;
    m_NeedSVGFunction = false;

    SetImagesForm();

    // Start threads early to process in background
    std::set<std::string> img_include_set;
    auto [thrd_get_events, thrd_need_img_func, thrd_collect_img_headers] =
        InitializeThreads(img_include_set);

    // If the code files are being written to disk, then UpdateEmbedNodes() has already been called.
    if (panel_type != NOT_PANEL)
    {
        ProjectImages.UpdateEmbedNodes();
    }

    std::vector<Node*> forms;
    Project.CollectForms(forms);

    m_panel_type = panel_type;

    m_header->Clear();
    m_source->Clear();
    m_source->SetTabToSpaces(2);
    m_source->SetLastLineBlank();

    WriteSourceHeader();

    m_set_enum_ids.clear();
    m_set_const_ids.clear();
    // Do this early to give threads a chance to run before we need to join them.
    BaseCodeGenerator::CollectIDs(m_form_node, m_set_enum_ids, m_set_const_ids);

    if (m_form_node->is_Gen(gen_Images))
    {
        m_source->writeLine();
        m_source->writeLine("require 'base64'");
        m_source->writeLine("require 'stringio'");
        m_source->writeLine();

        thrd_get_events.join();
        ScriptCommon::JoinThreadSafely(thrd_collect_img_headers);
        thrd_need_img_func.join();
        GenerateImagesForm();
        return;
    }

    m_header->writeLine(
        "WX_GLOBAL_CONSTANTS = true unless defined? WX_GLOBAL_CONSTANTS\n\nrequire 'wx/core'");
    m_header->writeLine(tt_string("# Sample inherited class from ")
                        << m_form_node->as_string(prop_class_name));
    m_header->writeLine();

    std::set<std::string> imports;
    WriteImports(imports);

    WriteRelativeRequires(forms);
    WriteIDConstants();

    ScriptCommon::JoinThreadSafely(thrd_collect_img_headers);

    if (m_embedded_images.size())
    {
        WriteImageRequireStatements(code);
    }

    m_source->writeLine();
    m_header->writeLine();
    m_header->writeLine(tt_string("requires '") << m_form_node->as_string(prop_ruby_file) << "'\n");
    m_header->writeLine();

    if (m_form_node->HasValue(prop_ruby_insert))
    {
        tt_string convert(m_form_node->as_string(prop_ruby_insert));
        convert.Replace("@@", "\n", tt::REPLACE::all);
        tt_string_vector lines(convert, '\n', tt::TRIM::right);
        for (auto& line: lines)
        {
            m_source->doWrite(line);
            m_source->doWrite("\n");
        }
        m_source->doWrite("\n");
    }

    WriteInheritedClass();
    GenerateConstructionCode(code);
    GenerateEventHandlers(code, thrd_get_events);

    thrd_need_img_func.join();

    WriteHelperFunctions();

    if (m_form_node->is_Gen(gen_wxWizard))
    {
        code.clear();
        // see for an example C:\rwCode\wxRuby3\samples\dialogs\wizard.rb
        // w = MyWizard.new(self)
        // w.run_wizard(w.get_page_area_sizer.get_item(0).get_window)
    }

    // Make certain indentation is reset after all construction code is written
    m_source->ResetIndent();
    m_header->ResetIndent();

    WriteEmbeddedImages(code);
    WriteRuboCopFooter();
}

auto RubyCodeGenerator::WriteSVGRequirements() -> void
{
    if (!m_zlib_requirement_written)
    {
        m_zlib_requirement_written = true;
        m_source->writeLine("require 'zlib'");
    }
    if (!m_base64_requirement_written)
    {
        m_base64_requirement_written = true;
        m_source->writeLine("require 'base64'");
    }
    if (!m_stringio_requirement_written)
    {
        m_stringio_requirement_written = true;
        m_source->writeLine("require 'stringio'");
    }
}

auto RubyCodeGenerator::WriteImagesFileImport(Code& code, Node* form) -> void
{
    tt_string import_name = form->as_string(prop_ruby_file).filename();
    import_name.remove_extension();
    code.Str("require_relative '").Str(import_name) << "'";
    m_source->writeLine(code);
    code.clear();
}

auto RubyCodeGenerator::ProcessImageFromImagesForm(const ImageFromImagesParameters& params) -> void
{
    if (!(*params.images_file_imported))
    {
        WriteImagesFileImport(*params.code, params.iter->get_Form());
        *params.images_file_imported = true;
    }

    if (params.iter->base_image().type == wxBITMAP_TYPE_SVG)
    {
        WriteSVGRequirements();
        *params.svg_import_libs = true;
    }
}

auto RubyCodeGenerator::ProcessExternalImage(const EmbeddedImage* iter, bool svg_import_libs)
    -> void
{
    if (iter->base_image().type == wxBITMAP_TYPE_SVG && !svg_import_libs)
    {
        WriteSVGRequirements();
    }

    if (!m_base64_requirement_written)
    {
        m_base64_requirement_written = true;
        m_source->writeLine("require 'base64'");
    }

    // At this point we know that some method is required, but until we have
    // processed all the images, we won't know if the images file is required.
    // The images file provides it's own function for loading images, so we can
    // use that if it's available.
    m_NeedImageFunction = true;
}

void RubyCodeGenerator::WriteImageRequireStatements(Code& code)
{
    ASSERT_MSG(m_embedded_images.size(),
               "CheckMimeBase64Requirement() should only be called if there are embedded images");
    if (m_embedded_images.empty())
    {
        return;
    }
    m_source->writeLine();

    bool images_file_imported = false;
    bool svg_import_libs = false;

    for (auto& iter: m_embedded_images)
    {
        if (iter->get_Form() == m_ImagesForm)
        {
            ProcessImageFromImagesForm(
                ImageFromImagesParameters { .iter = iter,
                                            .images_file_imported = &images_file_imported,
                                            .svg_import_libs = &svg_import_libs,
                                            .code = &code });
        }
        else
        {
            ProcessExternalImage(iter, svg_import_libs);
        }
    }

    if (m_NeedImageFunction && images_file_imported)
    {
        // The images file supplies the function we need
        m_NeedImageFunction = false;
    }
    else if (m_NeedImageFunction && !m_stringio_requirement_written)
    {
        // We have to provide our own method, and that requires this library
        m_source->writeLine("require 'stringio'");
    }
}

constexpr std::uint32_t MAX_UINT32 = 0xFFFFFFFF;

void RubyCodeGenerator::GenerateImagesForm()
{
    if (m_embedded_images.empty() || !m_form_node->get_ChildCount())
    {
        return;
    }

    m_source->writeLine(txt_ruby_get_bundle, indent::auto_keep_whitespace);

    Code code(m_form_node, GEN_LANG_RUBY);

    for (const auto* iter_array: m_embedded_images)
    {
        if (iter_array->get_Form() != m_form_node)
        {
            continue;
        }

        if (iter_array->base_image().filename.size())
        {
            code.Eol().Str("# ").Str(iter_array->base_image().filename);
        }
        code.Eol().Str("$").Str(iter_array->base_image().array_name);
        if (iter_array->base_image().type == wxBITMAP_TYPE_SVG)
        {
            code.Str(" = (");
        }
        else
        {
            code.Str(" = Base64.decode64(");
        }
        m_source->writeLine(code);
        code.clear();
        auto encoded =
            base64_encode(iter_array->base_image().array_data.get(),
                          iter_array->base_image().array_size & MAX_UINT32, GEN_LANG_RUBY);
        if (encoded.size())
        {
            // Remove the trailing '+' character
            encoded.back().pop_back();
            // and the now trailing space
            encoded.back().pop_back();
            encoded.back() += ")";
            m_source->writeLine(encoded);
        }
    }

    m_source->writeLine();
}

auto RubyCodeGenerator::CollectExistingEventHandlers(std::unordered_set<std::string>& code_lines)
    -> bool
{
    return ScriptCommon::CollectExistingEventHandlers(m_form_node, GEN_LANG_RUBY, m_panel_type,
                                                      code_lines, "def ");
}

auto RubyCodeGenerator::GenerateEventHandlerComment(bool found_user_handlers, Code& code) -> void
{
    ScriptCommon::GenerateEventHandlerComment(found_user_handlers, code, GEN_LANG_RUBY);
}

auto RubyCodeGenerator::GenerateEventHandlerBody(NodeEvent* event, Code& undefined_handlers) -> void
{
    ScriptCommon::GenerateEventHandlerBody(event, undefined_handlers, GEN_LANG_RUBY);
}

auto RubyCodeGenerator::WriteEventHandlers(Code& code, Code& undefined_handlers) -> void
{
    if (undefined_handlers.size())
    {
        m_source->writeLine(code, indent::none);
        m_source->writeLine(ruby_begin_cmt_block, indent::none);
        m_source->writeLine(undefined_handlers);
        m_source->writeLine("end", indent::none);
        m_source->writeLine(ruby_end_cmt_block, indent::none);

        m_header->writeLine("# Event handler functions");
        m_header->writeLine(undefined_handlers);
    }
}

void RubyCodeGenerator::GenUnhandledEvents(EventVector& events)
{
    ASSERT_MSG(events.size(), "GenUnhandledEvents() shouldn't be called if there are no events");
    if (events.empty())
    {
        return;
    }

    // Multiple events can be bound to the same function, so use a set to make sure we only generate
    // each function once.
    std::unordered_set<std::string> code_lines;

    Code code(m_form_node, GEN_LANG_RUBY);
    auto sort_event_handlers = [](NodeEvent* event_a, NodeEvent* event_b)
    {
        return (EventHandlerDlg::GetRubyValue(event_a->get_value()) <
                EventHandlerDlg::GetRubyValue(event_b->get_value()));
    };

    // Sort events by function name
    std::ranges::sort(events, sort_event_handlers);

    bool inherited_class = m_form_node->HasValue(prop_ruby_inherit_name);
    if (!inherited_class)
    {
        m_header->Indent();
    }
    else
    {
        m_header->Unindent();
        m_header->writeLine();
    }

    bool found_user_handlers = CollectExistingEventHandlers(code_lines);
    GenerateEventHandlerComment(found_user_handlers, code);

    Code undefined_handlers(m_form_node, GEN_LANG_RUBY);
    for (auto& event: events)
    {
        auto ruby_handler = EventHandlerDlg::GetRubyValue(event->get_value());
        // Ignore lambda's
        if (ruby_handler.empty() || ruby_handler.starts_with("[ruby:lambda]"))
        {
            continue;
        }

        wxString set_code;
        set_code << "def " << ruby_handler << "(event)";
        if (code_lines.contains(set_code.ToStdString()))
        {
            continue;
        }
        code_lines.emplace(set_code);

        undefined_handlers.Str(set_code.ToStdString()).Eol();
        GenerateEventHandlerBody(event, undefined_handlers);
        undefined_handlers.Eol().Unindent();
        undefined_handlers.Str("end").Eol();
    }

    WriteEventHandlers(code, undefined_handlers);
    m_header->Unindent();
}

auto MakeRubyPath(Node* node) -> tt_string
{
    return ScriptCommon::MakeScriptPath(node, GEN_LANG_RUBY);
}
