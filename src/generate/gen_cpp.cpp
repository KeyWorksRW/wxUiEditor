/////////////////////////////////////////////////////////////////////////////
// Purpose:   Generate C++ code files
// Author:    Ralph Walden
// Copyright: Copyright (c) 2020-2023 KeyWorks Software (Ralph Walden)
// License:   Apache License -- see ../../LICENSE
/////////////////////////////////////////////////////////////////////////////

#include <set>
#include <unordered_set>

#include "mainframe.h"

#include "base_generator.h"   // BaseGenerator -- Base widget generator class
#include "code.h"             // Code -- Helper class for generating code
#include "file_codewriter.h"  // FileCodeWriter -- Classs to write code to disk
#include "gen_base.h"         // BaseCodeGenerator -- Generate Src and Hdr files for Base Class
#include "gen_common.h"       // Common component functions
#include "gen_results.h"      // Code generation file writing functions
#include "image_gen.h"        // Functions for generating embedded images
#include "image_handler.h"    // ImageHandler class
#include "node.h"             // Node class
#include "project_handler.h"  // ProjectHandler class
#include "utils.h"            // Miscellaneous utilities
#include "write_code.h"       // Write code to Scintilla or file

#include "pugixml.hpp"

using namespace code;

extern std::map<wxBitmapType, std::string> g_map_handlers;
extern std::map<wxBitmapType, std::string> g_map_types;

// clang-format off

inline constexpr const auto txt_wxueImageFunction = R"===(
// Convert a data array into a wxImage
inline wxImage wxueImage(const unsigned char* data, size_t size_data)
{
    wxMemoryInputStream strm(data, size_data);
    wxImage image;
    image.LoadFile(strm);
    return image;
};
)===";

inline constexpr const auto txt_GetBundleFromSVG = R"===(
// Convert compressed SVG string into a wxBitmapBundle
inline wxBitmapBundle wxueBundleSVG(const unsigned char* data,
    size_t size_data, size_t size_svg, wxSize def_size)
{
    auto str = std::make_unique<char[]>(size_svg);
    wxMemoryInputStream stream_in(data, size_data);
    wxZlibInputStream zlib_strm(stream_in);
    zlib_strm.Read(str.get(), size_svg);
    return wxBitmapBundle::FromSVG(str.get(), def_size);
};
)===";

inline constexpr const auto txt_GetAnimFromHdrFunction = R"===(
// Convert a data array into a wxAnimation
inline wxAnimation wxueAnimation(const unsigned char* data, size_t size_data)
{
    wxMemoryInputStream strm(data, size_data);
    wxAnimation animation;
    animation.Load(strm);
    return animation;
};
)===";

inline constexpr const auto txt_BaseCmtBlock =
R"===(///////////////////////////////////////////////////////////////////////////////
// Code generated by wxUiEditor - see https://github.com/KeyWorksRW/wxUiEditor/
//
// Do not edit any code above the "End of generated code" comment block.
// Any changes before that block will be lost if it is re-generated!
///////////////////////////////////////////////////////////////////////////////

// clang-format off

)===";

// clang-format on

void BaseCodeGenerator::GenerateCppClass(Node* form_node, PANEL_PAGE panel_type)
{
    ASSERT(form_node)
    ASSERT(m_language == GEN_LANG_CPLUSPLUS)

    Code code(form_node, GEN_LANG_CPLUSPLUS);

    m_CtxMenuEvents.clear();
    m_embedded_images.clear();
    m_type_generated.clear();

    m_form_node = form_node;
    m_ImagesForm = nullptr;
    m_TranslationUnit = (form_node->as_bool(prop_generate_translation_unit) || form_node->isGen(gen_Images));

    for (const auto& form: Project.getChildNodePtrs())
    {
        if (form->isGen(gen_folder))
        {
            for (const auto& child_form: form->getChildNodePtrs())
            {
                if (child_form->isGen(gen_Images))
                {
                    m_ImagesForm = child_form.get();
                    break;
                }
            }
            break;
        }

        else if (form->isGen(gen_Images))
        {
            m_ImagesForm = form.get();
            break;
        }
    }

    m_NeedAnimationFunction = false;
    m_NeedHeaderFunction = false;
    m_NeedSVGFunction = false;
    m_NeedArtProviderHeader = false;
    m_NeedImageFunction = false;

    EventVector events;
    std::thread thrd_get_events(&BaseCodeGenerator::CollectEventHandlers, this, form_node, std::ref(events));
    std::thread thrd_need_img_func(&BaseCodeGenerator::ParseImageProperties, this, form_node);

    // If the code files are being written to disk, then UpdateEmbedNodes() has already been called.
    if (panel_type != NOT_PANEL)
    {
        ProjectImages.UpdateEmbedNodes();
    }

    m_panel_type = panel_type;

    m_header->Clear();
    m_source->Clear();
    m_source->SetLastLineBlank();
    m_header->SetLastLineBlank();

    if (m_panel_type == NOT_PANEL)
    {
        m_header->writeLine(txt_BaseCmtBlock);
        if (m_TranslationUnit)
        {
            m_source->writeLine(txt_BaseCmtBlock);
        }
    }

    tt_string file;
    if (auto& base_file = form_node->as_string(prop_base_file); base_file.size())
    {
        tt_cwd cwd(true);
        Project.ChangeDir();
        file = base_file;
        file.make_relative(Project.getProjectPath());
        file.backslashestoforward();
        file.remove_extension();

        m_baseFullPath = base_file;
        m_baseFullPath.make_absolute();
        m_baseFullPath.remove_filename();
    }

    // Caution! CollectImageHeaders() needs access to m_baseFullPath, so don't start this thread until it has been set!
    std::set<std::string> img_include_set;
    std::thread thrd_collect_img_headers(&BaseCodeGenerator::CollectImageHeaders, this, form_node,
                                         std::ref(img_include_set));

    m_header->writeLine("#pragma once");
    m_header->writeLine();

    std::set<std::string> src_includes;
    std::set<std::string> hdr_includes;
    if (Project.as_string(prop_help_provider) != "none")
        src_includes.insert("#include <wx/cshelp.h>");
    if (Project.as_bool(prop_internationalize))
        hdr_includes.insert("#include <wx/intl.h>");

    // This will almost always be needed, and it in turn includes a bunch of other files like string.h which are also
    // almost always needed.
    hdr_includes.insert("#include <wx/gdicmn.h>");

    CollectIncludes(form_node, src_includes, hdr_includes);

    thrd_get_events.join();
    if (events.size() || m_CtxMenuEvents.size())
    {
        hdr_includes.insert("#include <wx/event.h>");
    }

    if (form_node->as_bool(prop_persist))
    {
        src_includes.insert("#include <wx/persist.h>");
        src_includes.insert("#include <wx/persist/toplevel.h>");
    }

    if (form_node->hasValue(prop_icon))
    {
        src_includes.insert("#include <wx/icon.h>");
    }

    thrd_need_img_func.join();

    if (m_NeedArtProviderHeader)
    {
        src_includes.insert("#include <wx/artprov.h>");
    }

    if (panel_type != CPP_PANEL)
    {
        // BUGBUG: [KeyWorks - 01-25-2021] Need to look for base_class_name property of all children, and add each name
        // as a forwarded class.

        if (!m_TranslationUnit)
        {
            // Without a translation unit, all the code that requires specific header files
            // will be generated in the header file, so add all the header files that were for
            // the source file to the header file instead. hdr_includes is a set, so this will
            // prevent duplicates.
            for (auto& iter: src_includes)
            {
                hdr_includes.insert(iter);
            }
        }

        // First output all the wxWidget header files
        for (auto& iter: hdr_includes)
        {
            if (tt::contains(iter, "<wx"))
                m_header->writeLine((tt_string&) iter);
        }

        m_header->writeLine();

        // Now output all the other header files (this will include forward class declarations)
        for (auto& iter: hdr_includes)
        {
            if (!tt::contains(iter, "<wx"))
                m_header->writeLine((tt_string&) iter);
        }

        m_header->writeLine();

        if (form_node->hasValue(prop_header_preamble))
        {
            WritePropHdrCode(form_node, prop_header_preamble);
        }

        if (form_node->hasValue(prop_system_hdr_includes))
        {
            m_header->writeLine();
            tt_view_vector list;
            list.SetString(form_node->as_string(prop_system_hdr_includes));
            for (auto& iter: list)
            {
                m_header->writeLine(tt_string("#include <") << iter << '>');
            }
        }

        if (form_node->hasValue(prop_local_hdr_includes))
        {
            m_header->writeLine();
            tt_view_vector list;
            list.SetString(form_node->as_string(prop_local_hdr_includes));
            for (auto& iter: list)
            {
                m_header->writeLine(tt_string("#include \"") << iter << '"');
            }
        }
    }

    if (form_node->hasValue(prop_cpp_conditional) && m_TranslationUnit)
    {
        if (!form_node->as_string(prop_cpp_conditional).starts_with("#"))
            code.Str("#if ");
        code.Str(form_node->as_string(prop_cpp_conditional));
        m_source->writeLine(code);
        m_source->writeLine();
        code.clear();
    }

    if (Project.hasValue(prop_local_pch_file) && m_TranslationUnit)
    {
        m_source->writeLine(tt_string() << "#include \"" << Project.as_string(prop_local_pch_file) << '"');
        m_source->writeLine();
    }

    // Make certain there is a blank line before the the wxWidget #includes
    m_source->writeLine();

    // All generators that use a wxBitmapBundle should add "#include <wx/bmpbndl.h>" to the header set. If the user specified
    // 3.1 for the wxWidgets library, then code generation will create conditional code that uses wxBitmapBundle if 3.1.6 or
    // wxBitmap if older. We need to conditionalize the header output by removing the "#include <wx/bmpbndl.h>" entry and
    // creating our own conditionalized header.

    if (Project.as_string(prop_wxWidgets_version) == "3.1")
    {
        if (auto bmpbndl_hdr = src_includes.find("#include <wx/bmpbndl.h>"); bmpbndl_hdr != src_includes.end())
        {
            src_includes.erase(bmpbndl_hdr);
            if (auto bitmap_hdr = src_includes.find("#include <wx/bitmap.h>"); bitmap_hdr != src_includes.end())
            {
                src_includes.erase(bitmap_hdr);
            }

            code.clear();
            code += "#if wxCHECK_VERSION(3, 1, 6)";
            code.Eol().Tab().Str("#include <wx/bmpbndl.h>");
            code.Eol().Str("#else");
            code.Eol().Tab().Str("#include <wx/bitmap.h>");
            code.Eol().Str("#endif");

            if (m_TranslationUnit)
            {
                m_source->writeLine(code);
                m_source->writeLine();
            }
            else
            {
                m_header->writeLine(code);
                m_header->writeLine();
            }
        }
    }

    if (auto& hdr_extension = Project.as_string(prop_header_ext); hdr_extension.size())
    {
        m_header_ext = hdr_extension;
    }

    if (m_TranslationUnit)
    {
        // First output all the wxWidget header files
        for (auto& iter: src_includes)
        {
            if (tt::contains(iter, "<wx"))
                m_source->writeLine((tt_string&) iter);
        }

        m_source->writeLine();

        // Now output all the other header files (this will include derived_class header files)
        for (auto& iter: src_includes)
        {
            if (!tt::contains(iter, "<wx"))
                m_source->writeLine((tt_string&) iter);
        }

        m_source->writeLine();

        if (Project.hasValue(prop_src_preamble))
        {
            WritePropSourceCode(Project.getProjectNode(), prop_src_preamble);
        }

        if (form_node->hasValue(prop_source_preamble))
        {
            WritePropSourceCode(form_node, prop_source_preamble);
        }

        if (form_node->hasValue(prop_system_src_includes))
        {
            m_source->writeLine();
            tt_view_vector list;
            list.SetString(form_node->as_string(prop_system_src_includes));
            for (auto& iter: list)
            {
                m_source->writeLine(tt_string("#include <") << iter << '>');
            }
        }

        if (file.empty())
        {
            m_source->writeLine();
            m_source->writeLine("// Specify the filename to use in the base_file property");
            m_source->writeLine("#include \"Your filename here\"");
        }
        else
        {
            file.replace_extension(m_header_ext);
            m_source->writeLine();
            m_source->writeLine(tt_string() << "#include \"" << file.filename() << "\"");
        }

        if (form_node->hasValue(prop_local_src_includes))
        {
            m_source->writeLine();
            tt_view_vector list;
            list.SetString(form_node->as_string(prop_local_src_includes));
            for (auto& iter: list)
            {
                m_source->writeLine(tt_string("#include \"") << iter << '"');
            }
        }

        m_source->writeLine();
    }

    thrd_collect_img_headers.join();
    std::sort(m_embedded_images.begin(), m_embedded_images.end(),
              [](const EmbeddedImage* a, const EmbeddedImage* b)
              {
                  return (a->array_name.compare(b->array_name) < 0);
              });

    if (m_panel_type != HDR_PANEL)
    {
        if (!img_include_set.empty())
        {
            for (auto& iter: img_include_set)
            {
                m_source->writeLine(iter.c_str());
            }

            m_source->writeLine();
        }
    }

    // Make a copy of the string so that we can tweak it
    tt_string namespace_prop = Project.as_string(prop_name_space);
    if (auto* node_namespace = form_node->getFolder(); node_namespace && node_namespace->hasValue(prop_folder_namespace))
    {
        namespace_prop = node_namespace->as_string(prop_folder_namespace);
    }
    size_t indent = 0;
    tt_string_vector names;
    if (namespace_prop.size())
    {
        // BUGBUG: [KeyWorks - 09-01-2021] tt_string_vector works fine with a string as the separator. So does
        // tt_view_vector which is what we should be using here.

        // tt_string_vector works with a single char, not a string.
        namespace_prop.Replace("::", ":");
        // we also accept using semi-colons to separate the namespaces
        namespace_prop.Replace(";", ":");
        names.SetString(namespace_prop, ':');
        tt_string using_name;
        m_header->writeLine();
        for (auto& iter: names)
        {
            m_header->writeLine(tt_string() << "namespace " << iter);
            m_header->writeLine("{");
            m_header->Indent();
            ++indent;

            if (using_name.empty())
            {
                using_name = "using namespace ";
            }
            else
            {
                using_name += "::";
            }
            using_name += iter;
        }
        m_header->SetLastLineBlank();

        if (using_name.size())
        {
            using_name << ';';
            m_source->writeLine(using_name);
        }
    }

    if (form_node->isGen(gen_Images))
    {
        GenerateImagesForm();
        return;
    }

    if (m_panel_type != CPP_PANEL)
    {
        GenerateCppClassHeader(form_node, events);
    }

    if (m_panel_type != HDR_PANEL && m_TranslationUnit)
    {
        // First, generate the header files needed

        m_source->writeLine();
        if (m_NeedAnimationFunction)
        {
            m_source->writeLine("#include <wx/animate.h>", indent::none);
        }
        if (m_NeedImageFunction || m_NeedHeaderFunction || m_NeedSVGFunction || m_NeedAnimationFunction)
        {
            m_source->writeLine("\n#include <wx/mstream.h>  // memory stream classes", indent::none);
        }
        if (m_NeedSVGFunction)
        {
            m_source->writeLine("#include <wx/zstream.h>  // zlib stream classes", indent::none);
            m_source->writeLine();
            m_source->writeLine("#include <memory>  // for std::make_unique", indent::none);
        }

        // Now generate the functions

        if (m_NeedImageFunction || m_NeedHeaderFunction)
        {
            tt_string_vector function;
            function.ReadString(txt_wxueImageFunction);
            for (auto& iter: function)
            {
                m_source->writeLine(iter, indent::none);
            }
            m_source->writeLine();
        }

        if (m_NeedSVGFunction)
        {
            if (Project.as_string(prop_wxWidgets_version) == "3.1")
            {
                m_source->writeLine();
                m_source->writeLine("#if !wxCHECK_VERSION(3, 1, 6)", indent::none);
                m_source->Indent();
                m_source->writeLine("#error \"You must build with wxWidgets 3.1.6 or later to use SVG images.\"",
                                    indent::auto_no_whitespace);
                m_source->Unindent();
                m_source->writeLine("#endif", indent::none);
            }

            tt_string_vector function;
            function.ReadString(txt_GetBundleFromSVG);
            for (auto& iter: function)
            {
                m_source->writeLine(iter, indent::none);
            }
            m_source->writeLine();
        }

        if (m_NeedAnimationFunction)
        {
            tt_string_vector function;
            function.ReadString(txt_GetAnimFromHdrFunction);
            for (auto& iter: function)
            {
                m_source->writeLine(iter, indent::none);
            }
        }

        if (m_embedded_images.size())
        {
            WriteImagePreConstruction(code);
            if (code.size())
            {
                m_source->writeLine(code);
            }
        }

        GenerateCppClassConstructor(form_node, events);

        if (m_embedded_images.size())
        {
            WriteImageConstruction(code);
        }
    }

    if (indent > 0)
    {
        while (indent > 0)
        {
            m_header->Unindent();
            m_header->writeLine(tt_string() << "} // namespace " << names[--indent]);
        }
        m_header->writeLine();
    }

    if (form_node->hasValue(prop_cpp_conditional) && m_TranslationUnit)
    {
        code.Eol().Str("#endif  // ").Str(form_node->as_string(prop_cpp_conditional));
        m_source->writeLine(code);
    }

    if (!m_TranslationUnit)
    {
        m_source->writeLine("// No code generated since generate_translation_unit is unchecked");
    }
}

void BaseCodeGenerator::GenerateCppClassHeader(Node* form_node, EventVector& events)
{
    ASSERT(m_language == GEN_LANG_CPLUSPLUS);

    if (form_node->isGen(gen_Images))
    {
        // There is a header for this, but it's not a class header
        return;
    }

    if (!form_node->hasValue(prop_class_name))
    {
        FAIL_MSG(tt_string("Missing \"name\" property in ") << form_node->declName());
        return;
    }

    auto generator = form_node->getNodeDeclaration()->getGenerator();
    Code code(form_node, GEN_LANG_CPLUSPLUS);

    // This may result in two blank lines, but without it there may be a case where there is no blank line at all.
    m_header->writeLine();
    if (!m_TranslationUnit)
    {
        WriteImagePreConstruction(code);
        if (code.size())
        {
            m_header->writeLine(code);
        }

        // First, generate the header files needed

        m_header->writeLine();
        if (m_NeedAnimationFunction)
        {
            m_header->writeLine("#include <wx/animate.h>", indent::none);
        }
        if (m_NeedImageFunction || m_NeedHeaderFunction || m_NeedSVGFunction || m_NeedAnimationFunction)
        {
            m_header->writeLine("\n#include <wx/mstream.h>  // memory stream classes", indent::none);
        }
        if (m_NeedSVGFunction)
        {
            m_header->writeLine("#include <wx/zstream.h>  // zlib stream classes", indent::none);
            m_header->writeLine();
            m_header->writeLine("#include <memory>  // for std::make_unique", indent::none);
        }

        if (m_NeedImageFunction || m_NeedHeaderFunction)
        {
            tt_string_vector function;
            function.ReadString(txt_wxueImageFunction);
            for (auto& iter: function)
            {
                m_header->writeLine(iter, indent::none);
            }
            m_header->writeLine();
        }

        if (m_NeedSVGFunction)
        {
            if (Project.as_string(prop_wxWidgets_version) == "3.1")
            {
                m_header->writeLine();
                m_header->writeLine("#if !wxCHECK_VERSION(3, 1, 6)", indent::none);
                m_header->Indent();
                m_header->writeLine("#error \"You must build with wxWidgets 3.1.6 or later to use SVG images.\"",
                                    indent::auto_no_whitespace);
                m_header->Unindent();
                m_header->writeLine("#endif", indent::none);
            }

            tt_string_vector function;
            function.ReadString(txt_GetBundleFromSVG);
            for (auto& iter: function)
            {
                m_header->writeLine(iter, indent::none);
            }
            m_header->writeLine();
        }

        if (m_NeedAnimationFunction)
        {
            tt_string_vector function;
            function.ReadString(txt_GetAnimFromHdrFunction);
            for (auto& iter: function)
            {
                m_header->writeLine(iter, indent::none);
            }
        }

        WriteImagePostHeader();
        m_header->writeLine();
    }

    if (generator->PreClassHeaderCode(code))
    {
        m_header->writeLine(code);
        code.clear();
    }

    if (m_embedded_images.size() && m_TranslationUnit)
    {
        WriteImagePostHeader();
        m_header->writeLine();
    }

    code.Str("class ");
    if (form_node->hasValue(prop_class_decoration))
        code.as_string(prop_class_decoration) += " ";
    code.as_string(prop_class_name) += " : public ";
    if (generator->BaseClassNameCode(code))
    {
        if (m_form_node->hasValue(prop_additional_inheritance))
        {
            tt_string_vector class_list(m_form_node->as_string(prop_additional_inheritance), '"', tt::TRIM::both);
            for (auto& iter: class_list)
            {
                code.Str(", public ").Str(iter);
            }
        }
        m_header->writeLine(code);
    }
    else
    {
        if (!form_node->isType(type_DocViewApp))
        {
            FAIL_MSG("All form generators need to support BaseClassNameCode() to provide the class name to derive from.");
        }
        // The only way this would be valid is if the base class didn't derive from anything.
        m_header->writeLine(tt_string() << "class " << form_node->as_string(prop_class_name));
    }

    m_header->writeLine("{");
    m_header->writeLine("public:");
    m_header->Indent();
    m_header->SetLastLineBlank();

    // The set is used to prevent duplicates and to write the lines sorted. Call WriteSetLines() to write the lines and
    // clear the set.
    std::set<std::string> code_lines;
    CollectMemberVariables(form_node, Permission::Public, code_lines);
    if (code_lines.size())
    {
        WriteSetLines(m_header, code_lines);
        m_header->writeLine();
    }

    if (form_node->as_bool(prop_const_values))
    {
        code.clear();
        if (form_node->hasProp(prop_id))
        {
            code.Eol(eol_if_needed).Str("const int form_id = ");
            if (form_node->as_string(prop_id).size())
                code.as_string(prop_id) += ";";
            else
                code.Str("wxID_ANY;");
        }
        if (form_node->hasProp(prop_style))
        {
            code.Eol(eol_if_needed).Str("const int form_style = ");
            if (form_node->as_string(prop_style).size())
                code.as_string(prop_style) += ";";
            else
                code.Str("0;");
        }
        else if (form_node->hasProp(prop_window_style))
        {
            code.Eol(eol_if_needed).Str("const int form_style = ");
            if (form_node->as_string(prop_window_style).size())
                code.as_string(prop_window_style) += ";";
            else
                code.Str("0;");
        }
        if (form_node->hasProp(prop_pos))
            code.Eol(eol_if_needed).Str("const wxPoint form_pos = ").Pos(prop_pos, no_dlg_units) += ";";
        if (form_node->hasProp(prop_size))
            code.Eol(eol_if_needed).Str("const wxSize form_size = ").WxSize(prop_size, no_dlg_units) += ";";
        if (form_node->hasProp(prop_title))
        {
            code.Eol(eol_if_needed).Str("static const wxString form_title() { return ");
            if (form_node->hasValue(prop_title))
                code.Str("wxString::FromUTF8(\"").as_string(prop_title) += "\"); }";
            else
                code.Str("wxEmptyString; }");
        }

        if (code.size())
        {
            m_header->writeLine(code);
            m_header->writeLine();
            m_header->writeLine();
        }
    }

    code.clear();
    if (generator->HeaderCode(code))
    {
        if (!m_TranslationUnit)
        {
            // We need to use the header version of the Create() declaration to get the default
            // parameters, but since we will be defining rather than declaring the function, we
            // have to remove the trailing ';'. When GenerateCppClassConstructor() is called, it
            // will remove it's initial definition of the Create() function, starting with a
            // '{' instead. All of this is required because you can't have a declaration and
            // definition in a class header file, and we need the default parameters for 2-step
            // construction to work.
            if (auto start = code.find("bool Create"); tt::is_found(start))
            {
                if (auto end = code.find(';', start); tt::is_found(end))
                {
                    // Remove all trailing whitespace -- when GenerateCppClassConstructor() is
                    // called, it will start with an opening brace.
                    size_t count = 2;
                    for (; end + count < code.size(); ++count)
                    {
                        if (!tt::is_whitespace(code[end + count]))
                            break;
                    }
                    code.erase(end, count);
                }
            }
        }
        m_header->writeLine(code);
    }

    if (!m_TranslationUnit)
    {
        GenerateCppClassConstructor(form_node, events);
        m_header->writeLine();
    }

    m_header->SetLastLineBlank();

    GenCppValidatorFunctions(form_node);
    m_header->writeLine();

    GenCppEnumIds(form_node);

    if (m_form_node->hasValue(prop_inserted_hdr_code))
    {
        WritePropHdrCode(m_form_node, prop_inserted_hdr_code);
    }

    if (m_form_node->hasValue(prop_class_methods))
    {
        m_header->writeLine();
        tt_string_vector class_list(m_form_node->as_string(prop_class_methods), '"', tt::TRIM::both);
        for (auto& iter: class_list)
        {
            m_header->writeLine(iter);
        }
        m_header->writeLine();
    }

    m_header->Unindent();
    m_header->writeLine("protected:");
    m_header->Indent();

    GenHdrEvents(events);

    if (!m_form_node->as_bool(prop_use_derived_class) && form_node->as_bool(prop_private_members))
    {
        m_header->Unindent();
        m_header->writeLine();
        m_header->writeLine("private:");
        m_header->Indent();
    }

    CollectValidatorVariables(form_node, code_lines);
    if (code_lines.size())
    {
        m_header->writeLine();
        m_header->writeLine("// Validator variables");
        m_header->writeLine();
        WriteSetLines(m_header, code_lines);
    }

    CollectMemberVariables(form_node, Permission::Protected, code_lines);
    generator->AddProtectedHdrMembers(code_lines);

    if (code_lines.size())
    {
        m_header->writeLine();
        m_header->writeLine("// Class member variables");
        m_header->writeLine();
        WriteSetLines(m_header, code_lines);
    }

    if (m_form_node->hasValue(prop_class_members))
    {
        tt_string_vector class_list(m_form_node->as_string(prop_class_members), '"', tt::TRIM::both);
        m_header->writeLine();
        for (auto& iter: class_list)
        {
            m_header->writeLine(iter);
        }
    }

    m_header->Unindent();
    if (not m_form_node->as_bool(prop_no_closing_brace))
    {
        m_header->writeLine("};");
    }

    if (m_embedded_images.size() && !m_TranslationUnit)
    {
        code.clear();

        if (m_embedded_images.size())
        {
            WriteImagePreConstruction(code);
            if (code.size())
            {
                m_header->writeLine(code);
            }
        }

        WriteImageConstruction(code);
    }
}

void BaseCodeGenerator::GenerateCppClassConstructor(Node* form_node, EventVector& events)
{
    ASSERT(m_language == GEN_LANG_CPLUSPLUS);

    // If we aren't generating a translation unit, then the construction code needs to be
    // written to the header file instead. Because we also call functions that assume we are
    // writing to m_source, we change m_source to m_header temporarily, restoring it at before
    // returning from this function.

    WriteCode* save_writer = m_TranslationUnit ? nullptr : m_source;
    if (!m_TranslationUnit)
    {
        m_source = m_header;
    }
    else
    {
        m_source->writeLine();
    }

    auto* generator = form_node->getGenerator();
    Code code(form_node, GEN_LANG_CPLUSPLUS);
    if (generator->ConstructionCode(code))
    {
        if (!m_TranslationUnit)
        {
            // Don't use the source code version of the Create() functions parameters. This is
            // set in the header file already with default parameters.
            tt_string find_str;
            find_str << "bool " << form_node->as_string(prop_class_name) << "::Create";
            if (auto start = code.find(find_str); tt::is_found(start))
            {
                if (auto end = code.find('{', start); tt::is_found(end))
                {
                    code.erase(start, end - start);
                }
            }
        }

        m_source->writeLine(code);
        m_source->Indent();

        if (form_node->isGen(gen_wxFrame) || form_node->isGen(gen_wxDialog) || form_node->isGen(gen_wxWizard))
        {
            // Write code to m_source that will load any image handlers needed by the form's class
            GenerateCppHandlers();
            if (form_node->hasValue(prop_icon))
            {
                auto icon_code = GenerateIconCode(form_node->as_string(prop_icon));
                m_source->writeLine(icon_code, indent::auto_keep_whitespace);
                m_source->writeLine();
            }
        }

        code.clear();
        if (generator->SettingsCode(code))
        {
            m_source->writeLine(code);
            m_source->writeLine();
        }
    }
    else
    {
        m_source->Indent();
    }

    if (!form_node->isGen(gen_wxWizard) && !form_node->isGen(gen_wxFrame))
    {
        // Write code to m_source that will load any image handlers needed by the form's class
        GenerateCppHandlers();
    }

    if (form_node->getPropPtr(prop_window_extra_style))
    {
        code.clear();
        code.GenWindowSettings();
        if (code.size())
        {
            // GenerateWindowSettings() can result in code within braces, so keep any leading whitespace.
            m_source->writeLine(code.GetView(), indent::auto_keep_whitespace);
        }
    }

    m_source->SetLastLineBlank();
    if (!form_node->isGen(gen_DocViewApp))
    {
        for (const auto& child: form_node->getChildNodePtrs())
        {
            if (child->isGen(gen_wxContextMenuEvent))
                continue;
            GenConstruction(child.get());
        }

        code.clear();
        if (generator->AfterChildrenCode(code))
        {
            if (code.size())
            {
                m_source->writeLine();
                m_source->writeLine(code);
            }
        }

        if (form_node->as_bool(prop_persist))
        {
            m_source->writeLine();
            tt_string tmp("wxPersistentRegisterAndRestore(this, \"");
            tmp << form_node->getNodeName() << "\");";
            m_source->writeLine(tmp);
        }

        AddPersistCode(form_node);

        if (events.size())
        {
            m_source->writeLine();
            m_source->writeLine("// Event handlers");
            GenSrcEventBinding(form_node, events);
        }
    }
    if (form_node->isGen(gen_wxDialog) || form_node->isGen(gen_wxFrame) || form_node->isGen(gen_PanelForm) ||
        form_node->isGen(gen_DocViewApp))
    {
        m_source->writeLine("\nreturn true;");
    }

    m_source->Unindent();
    m_source->writeLine("}");

    if (form_node->isGen(gen_DocViewApp))
    {
        for (const auto& child: form_node->getChildNodePtrs())
        {
            if (child->isGen(gen_wxContextMenuEvent))
                continue;
            GenConstruction(child.get());
        }

        code.clear();
        if (generator->AfterChildrenCode(code))
        {
            if (code.size())
            {
                m_source->writeLine();
                m_source->writeLine(code);
            }
        }
    }

    code.clear();
    if (generator->AfterConstructionCode(code))
    {
        m_source->writeLine();
        m_source->writeLine(code);
    }

    Node* node_ctx_menu = nullptr;
    for (const auto& child: form_node->getChildNodePtrs())
    {
        if (child->isGen(gen_wxContextMenuEvent))
        {
            node_ctx_menu = child.get();
            break;
        }
    }

    if (node_ctx_menu)
    {
        GenContextMenuHandler(node_ctx_menu);
    }

    // This is critical! m_source will have been changed to m_header if there is no translation
    // unit, so we *must* restore it here.
    if (save_writer)
    {
        m_source = save_writer;
    }
}

void BaseCodeGenerator::GenerateCppHandlers()
{
    ASSERT(m_language == GEN_LANG_CPLUSPLUS);

    if (m_embedded_images.size())
    {
        for (auto& iter_img: m_embedded_images)
        {
            // wxBITMAP_TYPE_INVALID means it is a zlib compressed SVG string
            if (iter_img->type != wxBITMAP_TYPE_BMP && iter_img->type != wxBITMAP_TYPE_INVALID &&
                m_type_generated.find(iter_img->type) == m_type_generated.end())
            {
                m_source->writeLine(tt_string("if (!wxImage::FindHandler(") << g_map_types[iter_img->type] << "))");
                m_source->Indent();
                m_source->writeLine(tt_string("\twxImage::AddHandler(new ") << g_map_handlers[iter_img->type] << ");");
                m_source->Unindent();
                m_type_generated.insert(iter_img->type);
            }
        }
        m_source->writeLine();
    }
}

void BaseCodeGenerator::GenCppValidatorFunctions(Node* node)
{
    ASSERT(m_language == GEN_LANG_CPLUSPLUS);

    if (node->hasValue(prop_validator_variable))
    {
        auto result = GenGetSetCode(node);
        if (result)
        {
            m_header->writeLine(result.value());
        }
    }

    for (const auto& child: node->getChildNodePtrs())
    {
        GenCppValidatorFunctions(child.get());
    }
}

void BaseCodeGenerator::GenCppValVarsBase(const NodeDeclaration* declaration, Node* node, std::set<std::string>& code_lines)
{
    ASSERT(m_language == GEN_LANG_CPLUSPLUS);

    if (auto& var_name = node->as_string(prop_validator_variable); var_name.size())
    {
        if (auto val_data_type = node->getValidatorDataType(); val_data_type.size())
        {
            tt_string code;

            if (node->hasValue(prop_platforms) && node->as_string(prop_platforms) != "Windows|Unix|Mac")
            {
                if (node->as_string(prop_platforms).contains("Windows"))
                    code << "\n#if defined(__WINDOWS__)";
                if (node->as_string(prop_platforms).contains("Unix"))
                {
                    if (code.size())
                        code << " || ";
                    else
                        code << "\n#if ";
                    code << "defined(__UNIX__)";
                }
                if (node->as_string(prop_platforms).contains("Mac"))
                {
                    if (code.size())
                        code << " || ";
                    else
                        code << "\n#if ";
                    code << "defined(__WXOSX__)";
                }
                code << "\n";
            }

            code << val_data_type << ' ' << var_name;

            if (val_data_type == "bool")
            {
                auto prop = node->getPropPtr(prop_checked);
                bool bState = (prop && prop->as_bool());
                if (!prop)
                {
                    prop = node->getPropPtr(prop_initial_state);
                    if (prop && prop->as_string() == "wxCHK_CHECKED")
                        bState = true;
                }
                code << " { " << (bState ? "true" : "false") << " };";
            }
            else if (val_data_type.contains("int") || val_data_type.contains("short") || val_data_type.contains("long") ||
                     val_data_type.contains("double") || val_data_type.contains("float"))
            {
                auto prop = node->getPropPtr(prop_value);
                if (!prop)
                    prop = node->getPropPtr(prop_initial);
                if (!prop)
                    prop = node->getPropPtr(prop_selection);
                if (!prop)
                    prop = node->getPropPtr(prop_position);
                if (prop && prop->as_string().size())
                {
                    code << " { " << prop->as_string() << " };";
                }
                else
                {
                    code << ';';
                }
            }
            else if (val_data_type == "wxString" || val_data_type == "wxFileName")
            {
                auto& value = node->as_string(prop_value);
                if (value.size())
                {
                    code << " { " << GenerateQuotedString(value) << " };";
                }
                else
                {
                    code << ';';
                }
            }
            // BUGBUG: [Randalphwa - 07-31-2023] We need to handle wxArrayInt
            else
            {
                code << ';';
            }

            if (node->hasValue(prop_platforms) && node->as_string(prop_platforms) != "Windows|Unix|Mac")
            {
                code << "\n#endif  // limited to specific platforms";
            }

            code_lines.insert(code);
        }
    }

    for (size_t i = 0; i < declaration->GetBaseClassCount(false); i++)
    {
        GenCppValVarsBase(declaration->GetBaseClass(i, false), node, code_lines);
    }
}

// This should only be called to generate C++ code.
void BaseCodeGenerator::GenCppEnumIds(Node* class_node)
{
    ASSERT(m_language == GEN_LANG_CPLUSPLUS);

    if (!class_node->as_bool(prop_generate_ids))
        return;

    std::set<std::string> set_enum_ids;
    std::set<std::string> set_const_ids;
    CollectIDs(class_node, set_enum_ids, set_const_ids);

    if (set_const_ids.size())
    {
        for (auto& iter: set_const_ids)
        {
            tt_string id = "static const int ";
            if (iter.starts_with("self."))
                m_header->write(id + (iter.c_str() + (sizeof("self.") - 1)));
            else
                m_header->write(id + iter);
            m_header->writeLine(";");
        }
        m_header->writeLine();
    }

    if (set_enum_ids.size())
    {
        m_header->writeLine("enum");
        m_header->writeLine("{");
        m_header->Indent();

        size_t item = 0;
        for (auto& iter: set_enum_ids)
        {
            if (iter.starts_with("self."))
                m_header->write(iter.c_str() + (sizeof("self.") - 1));
            else
                m_header->write(iter);
            if (item == 0)
            {
                if (class_node->hasValue(prop_initial_enum_string))
                    m_header->write(" = " + class_node->as_string(prop_initial_enum_string));
                else
                    m_header->write(" = wxID_HIGHEST + 1", true);
            }

            if (item < set_enum_ids.size() - 1)
            {
                m_header->writeLine(",");
            }
            ++item;
        }

        m_header->Unindent();
        m_header->writeLine();
        m_header->writeLine("};");
        m_header->writeLine();
    }
}
