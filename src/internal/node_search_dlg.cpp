///////////////////////////////////////////////////////////////////////////////
// Code generated by wxUiEditor - see https://github.com/KeyWorksRW/wxUiEditor/
//
// Do not edit any code above the "End of generated code" comment block.
// Any changes before that block will be lost if it is re-generated!
///////////////////////////////////////////////////////////////////////////////

// clang-format off

#include <wx/button.h>
#include <wx/persist.h>
#include <wx/persist/toplevel.h>
#include <wx/radiobut.h>
#include <wx/sizer.h>
#include <wx/stattext.h>
#include <wx/valgen.h>

#include "node_search_dlg.h"

#include "../panels/nav_panel.h"
#include "mainframe.h"
#include "node.h"
#include "project_handler.h"
#include "unused_gen_dlg.h"

bool NodeSearchDlg::Create(wxWindow* parent, wxWindowID id, const wxString& title,
    const wxPoint& pos, const wxSize& size, long style, const wxString &name)
{
    // Scaling of pos and size are handled after the dialog
    // has been created and controls added.
    if (!wxDialog::Create(parent, id, title, pos, size, style, name))
    {
        return false;
    }

    auto* dlg_sizer = new wxBoxSizer(wxVERTICAL);

    auto* box_sizer_3 = new wxBoxSizer(wxHORIZONTAL);
    box_sizer_3->SetMinSize(500, -1);

    auto* radioBtn_Generators = new wxRadioButton(this, wxID_ANY, "&Generators", wxDefaultPosition, wxDefaultSize, wxRB_GROUP);
    radioBtn_Generators->SetValue(true);
    radioBtn_Generators->SetValidator(wxGenericValidator(&m_search_generators));
    box_sizer_3->Add(radioBtn_Generators, wxSizerFlags().Border(wxALL));

    auto* radio_variables = new wxRadioButton(this, wxID_ANY, "&Variables");
    radio_variables->SetValidator(wxGenericValidator(&m_search_varnames));
    box_sizer_3->Add(radio_variables, wxSizerFlags().Border(wxALL));

    auto* radioBtn_Labels = new wxRadioButton(this, wxID_ANY, "&Labels");
    radioBtn_Labels->SetValidator(wxGenericValidator(&m_search_labels));
    box_sizer_3->Add(radioBtn_Labels, wxSizerFlags().Border(wxALL));

    auto* radioBtn_IDs = new wxRadioButton(this, wxID_ANY, "&IDs");
    radioBtn_IDs->SetValidator(wxGenericValidator(&m_search_ids));
    box_sizer_3->Add(radioBtn_IDs, wxSizerFlags().Border(wxALL));

    auto* btn = new wxButton(this, wxID_ANY, "Unused...");
    box_sizer_3->Add(btn, wxSizerFlags().Border(wxLEFT|wxRIGHT|wxBOTTOM, wxSizerFlags::GetDefaultBorder()));

    dlg_sizer->Add(box_sizer_3, wxSizerFlags().Expand().Border(wxALL));

    auto* box_sizer = new wxBoxSizer(wxHORIZONTAL);

    m_text_search = new wxTextCtrl(this, wxID_ANY, wxEmptyString);
    m_text_search->SetHint("Enter item to search for");
    box_sizer->Add(m_text_search, wxSizerFlags().Border(wxLEFT|wxRIGHT|wxTOP, wxSizerFlags::GetDefaultBorder()));

    dlg_sizer->Add(box_sizer, wxSizerFlags().Border(wxALL));

    auto* box_sizer_4 = new wxBoxSizer(wxHORIZONTAL);
    box_sizer_4->SetMinSize(500, -1);

    auto* box_sizer_5 = new wxBoxSizer(wxVERTICAL);

    auto* staticText = new wxStaticText(this, wxID_ANY, "&Located:");
    box_sizer_5->Add(staticText, wxSizerFlags().Border(wxLEFT|wxRIGHT|wxTOP, wxSizerFlags::GetDefaultBorder()));

    m_listbox = new wxListBox(this, wxID_ANY);
    m_listbox->SetMinSize(FromDIP(wxSize(240, 250)));
    box_sizer_5->Add(m_listbox, wxSizerFlags(1).Expand().Border(wxALL));

    box_sizer_4->Add(box_sizer_5, wxSizerFlags(1).Expand().Border(wxALL));

    auto* box_sizer_6 = new wxBoxSizer(wxVERTICAL);

    auto* staticText_2 = new wxStaticText(this, wxID_ANY, "&Forms:");
    box_sizer_6->Add(staticText_2, wxSizerFlags().Border(wxLEFT|wxRIGHT|wxTOP, wxSizerFlags::GetDefaultBorder()));

    m_listbox_forms = new wxListBox(this, wxID_ANY, wxDefaultPosition, wxDefaultSize, 0, nullptr, wxLB_SINGLE|wxLB_SORT);
    m_listbox_forms->SetMinSize(FromDIP(wxSize(-1, 250)));
    box_sizer_6->Add(m_listbox_forms, wxSizerFlags(1).Expand().Border(wxALL));

    box_sizer_4->Add(box_sizer_6, wxSizerFlags(1).Expand().Border(wxALL));

    dlg_sizer->Add(box_sizer_4, wxSizerFlags(1).Expand().Border(wxLEFT|wxRIGHT|wxBOTTOM, wxSizerFlags::GetDefaultBorder()));

    auto* stdBtn = CreateStdDialogButtonSizer(wxOK|wxCANCEL);
    dlg_sizer->Add(CreateSeparatedSizer(stdBtn), wxSizerFlags().Expand().Border(wxALL));

    if (pos != wxDefaultPosition)
    {
        // Now that the dialog is created, set the scaled position
        SetPosition(FromDIP(pos));
    }
    if (size == wxDefaultSize)
    {
        // If default size let the sizer set the dialog's size
        // so that it is large enough to fit it's child controls.
        SetSizerAndFit(dlg_sizer);
    }
    else
    {
        SetSizer(dlg_sizer);
        if (size.x == wxDefaultCoord || size.y == wxDefaultCoord)
        {
            // Use the sizer to calculate the missing dimension
            Fit();
        }
        SetSize(FromDIP(size));
        Layout();
    }
    m_text_search->SetFocus();

    Centre(wxBOTH);

    wxPersistentRegisterAndRestore(this, "NodeSearchDlg");

    // Event handlers
    Bind(wxEVT_BUTTON, &NodeSearchDlg::OnOK, this, wxID_OK);
    btn->Bind(wxEVT_BUTTON, &NodeSearchDlg::OnUnused, this);
    Bind(wxEVT_INIT_DIALOG, &NodeSearchDlg::OnInit, this);
    m_listbox->Bind(wxEVT_LISTBOX, &NodeSearchDlg::OnSelectLocated, this);
    radioBtn_Generators->Bind(wxEVT_RADIOBUTTON, &NodeSearchDlg::OnGenerators, this);
    radioBtn_IDs->Bind(wxEVT_RADIOBUTTON, &NodeSearchDlg::OnIDs, this);
    radioBtn_Labels->Bind(wxEVT_RADIOBUTTON, &NodeSearchDlg::OnLabels, this);
    radio_variables->Bind(wxEVT_RADIOBUTTON, &NodeSearchDlg::OnVariables, this);
    m_text_search->Bind(wxEVT_TEXT, &NodeSearchDlg::OnSearchText, this);

    return true;
}

// ************* End of generated code ***********
// DO NOT EDIT THIS COMMENT BLOCK!
//
// Code below this comment block will be preserved
// if the code for this class is re-generated.
//
// clang-format on
// ***********************************************

/////////////////// Non-generated Copyright/License Info ////////////////////
// Author:    Ralph Walden
// Copyright: Copyright (c) 2022-2023 KeyWorks Software (Ralph Walden)
// License:   Apache License -- see ../../LICENSE
/////////////////////////////////////////////////////////////////////////////

Node* FindNodeByClassName(Node* node_start, const std::string& classname)
{
    for (const auto& child_form: node_start->get_ChildNodePtrs())
    {
        if (child_form->is_Gen(gen_Images) || child_form->is_Gen(gen_Data))
            continue;

        if (child_form->HasValue(prop_class_name) &&
            child_form->as_string(prop_class_name) == classname)
            return child_form.get();

        if (child_form->is_Gen(gen_folder) || child_form->is_Gen(gen_sub_folder))
        {
            if (auto result = FindNodeByClassName(child_form.get(), classname); result)
            {
                return result;
            }
        }
    }

    return nullptr;
}

Node* FindNodeByGenerator(Node* node, GenEnum::GenName get_GenName)
{
    if (node->is_Gen(get_GenName))
        return node;

    for (auto& child: node->get_ChildNodePtrs())
    {
        auto result = FindNodeByGenerator(child.get(), get_GenName);
        if (result)
            return result;
    }

    return nullptr;
}

void MainFrame::OnFindWidget(wxCommandEvent& /* event unused */)
{
    NodeSearchDlg dlg(this);
    if (dlg.ShowModal() == wxID_OK && dlg.GetForm())
    {
        // Recursively search for the first Node* containing a property with a specific value.
        auto FindNodeByProp = [&](Node* node, GenEnum::PropName prop, const std::string& label_name,
                                  auto&& FindNodeByProp) -> Node*
        {
            if (node->HasValue(prop) && node->as_string(prop) == label_name)
                return node;

            for (auto& child: node->get_ChildNodePtrs())
            {
                auto result = FindNodeByProp(child.get(), prop, label_name, FindNodeByProp);
                if (result)
                    return result;
            }

            return nullptr;
        };

        if (dlg.isSearchGenerators())
        {
            auto* node = FindNodeByGenerator(dlg.GetForm(), rmap_GenNames[dlg.GetNameChoice()]);
            if (node)
            {
                SelectNode(node);
                m_nav_panel->SetFocus();
            }
            else
            {
                wxMessageBox(wxString() << "Unable to find " << dlg.GetName());
            }
        }
        else if (dlg.isSearchVarnames())
        {
            auto node =
                FindNodeByProp(dlg.GetForm(), prop_var_name, dlg.GetNameChoice(), FindNodeByProp);
            if (node)
            {
                SelectNode(node);
                m_nav_panel->SetFocus();
            }
            else
            {
                wxMessageBox(wxString() << "Unable to find " << dlg.GetNameChoice());
            }
        }
        else if (dlg.isSearchLabels())
        {
            auto node =
                FindNodeByProp(dlg.GetForm(), prop_label, dlg.GetNameChoice(), FindNodeByProp);
            if (node)
            {
                SelectNode(node);
                m_nav_panel->SetFocus();
            }
            else
            {
                wxMessageBox(wxString() << "Unable to find " << dlg.GetNameChoice());
            }
        }
        else if (dlg.isSearchIDs())
        {
            auto node = FindNodeByProp(dlg.GetForm(), prop_id, dlg.GetNameChoice(), FindNodeByProp);
            if (node)
            {
                SelectNode(node);
                m_nav_panel->SetFocus();
            }
            else
            {
                wxMessageBox(wxString() << "Unable to find " << dlg.GetNameChoice());
            }
        }
        else
        {
            wxMessageBox("No selected node, or search criteria selected");
        }
    }
}

void NodeSearchDlg::FindGenerators(Node* node)
{
    if (node->is_Gen(gen_Images) || node->is_Gen(gen_Data))
        return;

    if (!node->is_Gen(gen_folder) && !node->is_Gen(gen_sub_folder))
    {
        if (!m_map_found.contains(std::string(map_GenNames.at(node->get_GenName()))))
        {
            std::set<Node*> list;
            if (!node->is_Form())
            {
                list.emplace(node->get_Form());
            }
            else
            {
                auto* parent = node->get_Parent();
                if (parent->is_Gen(gen_folder) || parent->is_Gen(gen_sub_folder))
                {
                    list.emplace(node->get_Form());
                }
                else
                {
                    list.emplace(Project.get_ProjectNode());
                }
            }
            m_map_found[std::string(map_GenNames.at(node->get_GenName()))] = list;
        }
        else if (!node->is_Form())
        {
            auto& list = m_map_found.at(std::string(map_GenNames.at(node->get_GenName())));
            list.emplace(node->is_Form() ? node->get_Parent() : node->get_Form());
        }
    }

    if (node->get_ChildCount())
    {
        for (auto& child: node->get_ChildNodePtrs())
        {
            FindGenerators(child.get());
        }
    }
}

void NodeSearchDlg::FindVariables(Node* node)
{
    if (node->is_Gen(gen_Images) || node->is_Gen(gen_Data))
        return;

    if (node->HasProp(prop_var_name) && node->HasValue(prop_var_name) &&
        !node->is_Gen(gen_folder) && !node->is_Gen(gen_sub_folder))
    {
        if (!m_map_found.contains(node->as_string(prop_var_name)))
        {
            std::set<Node*> form_list;
            if (!node->is_Form())
            {
                form_list.emplace(node->get_Form());
            }
            else
            {
                auto* parent = node->get_Parent();
                if (parent->is_Gen(gen_folder) || parent->is_Gen(gen_sub_folder))
                {
                    form_list.emplace(node->get_Form());
                }
                else
                {
                    form_list.emplace(Project.get_ProjectNode());
                }
            }
            m_map_found[node->as_string(prop_var_name)] = form_list;
        }
        else if (!node->is_Form())
        {
            auto& form_list = m_map_found.at(node->as_string(prop_var_name));
            form_list.emplace(node->is_Form() ? node->get_Parent() : node->get_Form());
        }
    }

    if (node->get_ChildCount())
    {
        for (auto& child: node->get_ChildNodePtrs())
        {
            FindVariables(child.get());
        }
    }
}

void NodeSearchDlg::FindLabels(Node* node)
{
    if (node->is_Gen(gen_Images) || node->is_Gen(gen_Data))
        return;

    if (node->HasProp(prop_label) && node->HasValue(prop_label) && !node->is_Gen(gen_folder) &&
        !node->is_Gen(gen_sub_folder))
    {
        if (!m_map_found.contains(node->as_string(prop_label)))
        {
            std::set<Node*> form_list;
            if (!node->is_Form())
            {
                form_list.emplace(node->get_Form());
            }
            else
            {
                auto* parent = node->get_Parent();
                if (parent->is_Gen(gen_folder) || parent->is_Gen(gen_sub_folder))
                {
                    form_list.emplace(node->get_Form());
                }
                else
                {
                    form_list.emplace(Project.get_ProjectNode());
                }
            }
            m_map_found[node->as_string(prop_label)] = form_list;
        }
        else if (!node->is_Form())
        {
            auto& form_list = m_map_found.at(node->as_string(prop_label));
            form_list.emplace(node->is_Form() ? node->get_Parent() : node->get_Form());
        }
    }

    if (node->get_ChildCount())
    {
        for (auto& child: node->get_ChildNodePtrs())
        {
            FindLabels(child.get());
        }
    }
}

void NodeSearchDlg::OnGenerators(wxCommandEvent& /* event unused */)
{
    m_map_found.clear();
    m_listbox->Clear();
    m_listbox_forms->Clear();

    if (auto cur_sel = wxGetFrame().getSelectedNode(); cur_sel)
    {
        if (cur_sel->is_Gen(gen_Project) || cur_sel->is_Gen(gen_folder) ||
            cur_sel->is_Gen(gen_sub_folder))
        {
            for (auto& child: cur_sel->get_ChildNodePtrs())
            {
                FindGenerators(child.get());
            }
        }
        else
        {
            FindGenerators(wxGetFrame().getSelectedNode());
        }
        for (auto& iter: m_map_found)
        {
            m_listbox->Append(iter.first);
        }
    }
}

void NodeSearchDlg::OnVariables(wxCommandEvent& /* event unused */)
{
    m_map_found.clear();
    m_listbox->Clear();
    m_listbox_forms->Clear();

    if (auto cur_sel = wxGetFrame().getSelectedNode(); cur_sel)
    {
        if (cur_sel->is_Gen(gen_Project) || cur_sel->is_Gen(gen_folder) ||
            cur_sel->is_Gen(gen_sub_folder))
        {
            for (auto& child: cur_sel->get_ChildNodePtrs())
            {
                FindVariables(child.get());
            }
        }
        else
        {
            FindVariables(wxGetFrame().getSelectedNode());
        }
        for (auto& iter: m_map_found)
        {
            m_listbox->Append(iter.first);
        }
    }
}

void NodeSearchDlg::OnLabels(wxCommandEvent& /* event unused */)
{
    m_map_found.clear();
    m_listbox->Clear();
    m_listbox_forms->Clear();

    if (auto cur_sel = wxGetFrame().getSelectedNode(); cur_sel)
    {
        if (cur_sel->is_Gen(gen_Project) || cur_sel->is_Gen(gen_folder) ||
            cur_sel->is_Gen(gen_sub_folder))
        {
            for (auto& child: cur_sel->get_ChildNodePtrs())
            {
                FindLabels(child.get());
            }
        }
        else
        {
            FindLabels(wxGetFrame().getSelectedNode());
        }
        for (auto& iter: m_map_found)
        {
            m_listbox->Append(iter.first);
        }
    }
}

void NodeSearchDlg::OnIDs(wxCommandEvent& /* event unused */)
{
    m_map_found.clear();
    m_listbox->Clear();
    m_listbox_forms->Clear();

    auto FindIDs = [&](Node* node, auto&& FindIDs) -> void
    {
        if (node->is_Gen(gen_Images) || node->is_Gen(gen_Data))
            return;

        if (!node->is_NonWidget() && node->HasProp(prop_id) && node->HasValue(prop_id) &&
            !node->as_string(prop_id).starts_with("wxID_ANY"))
        {
            if (!m_map_found.contains(node->as_string(prop_id)))
            {
                std::set<Node*> form_list;
                if (!node->is_Form())
                {
                    form_list.emplace(node->get_Form());
                }
                else
                {
                    auto* parent = node->get_Parent();
                    if (parent->is_Gen(gen_folder) || parent->is_Gen(gen_sub_folder))
                    {
                        form_list.emplace(node->get_Form());
                    }
                    else
                    {
                        form_list.emplace(Project.get_ProjectNode());
                    }
                }
                m_map_found[node->as_string(prop_id)] = form_list;
            }
            else if (!node->is_Form())
            {
                auto& form_list = m_map_found.at(node->as_string(prop_id));
                form_list.emplace(node->is_Form() ? node->get_Parent() : node->get_Form());
            }
        }

        if (node->get_ChildCount())
        {
            for (auto& child: node->get_ChildNodePtrs())
            {
                FindIDs(child.get(), FindIDs);
            }
        }
    };

    if (auto cur_sel = wxGetFrame().getSelectedNode(); cur_sel)
    {
        if (cur_sel->is_Gen(gen_Project) || cur_sel->is_Gen(gen_folder) ||
            cur_sel->is_Gen(gen_sub_folder))
        {
            for (auto& child: cur_sel->get_ChildNodePtrs())
            {
                FindIDs(child.get(), FindIDs);
            }
        }
        else
        {
            FindIDs(wxGetFrame().getSelectedNode(), FindIDs);
        }
        for (auto& iter: m_map_found)
        {
            m_listbox->Append(iter.first);
        }
    }
}

void NodeSearchDlg::OnInit(wxInitDialogEvent& event)
{
    wxCommandEvent dummy;
    OnGenerators(dummy);

    m_text_search->SetFocus();

    event.Skip();
}

void NodeSearchDlg::OnOK(wxCommandEvent& event)
{
    if (m_listbox->GetCount() > 0)
    {
        m_name = m_listbox->GetStringSelection().ToStdString();
        if (m_listbox_forms->GetCount() > 0)
        {
            if (auto class_name = m_listbox_forms->GetStringSelection().ToStdString();
                class_name.size())
            {
                m_form = FindNodeByClassName(Project.get_ProjectNode(), class_name);
            }
            else
            {
                m_form = wxGetFrame().getSelectedNode();
            }
        }
        else if (wxGetFrame().getSelectedNode()->is_Form())
        {
            m_form = wxGetFrame().getSelectedNode();
        }
        else
        {
            m_form = wxGetFrame().getSelectedNode()->get_Form();
        }
    }

    event.Skip();
}

void NodeSearchDlg::OnSelectLocated(wxCommandEvent& /* event unused */)
{
    auto name = m_listbox->GetStringSelection().utf8_string();
    if (m_map_found.contains(name))
    {
        auto& list = m_map_found.at(name);
        m_listbox_forms->Clear();
        for (auto& iter: list)
        {
            m_listbox_forms->Append(iter->as_string(prop_class_name).make_wxString());
        }
        if (m_listbox_forms->GetCount() > 0)
        {
            m_listbox_forms->SetSelection(0);
        }
    }
}

void NodeSearchDlg::OnUnused(wxCommandEvent& /* event unused */)
{
    UnusedGenerators dlg(this);
    dlg.ShowModal();
}

void NodeSearchDlg::OnSearchText(wxCommandEvent& /* event unused */)
{
    auto search_text = m_text_search->GetValue().ToStdString();
    for (auto& iter: m_map_found)
    {
        if (iter.first.starts_with(search_text))
        {
            m_listbox->SetSelection(m_listbox->FindString(iter.first));
            wxCommandEvent dummy_event;
            OnSelectLocated(dummy_event);
            break;
        }
    }
}
