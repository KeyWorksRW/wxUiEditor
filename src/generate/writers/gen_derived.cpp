/////////////////////////////////////////////////////////////////////////////
// Purpose:   Generate the C++ derived class source and header file
// Author:    Ralph Walden
// Copyright: Copyright (c) 2020-2025 KeyWorks Software (Ralph Walden)
// License:   Apache License -- see ../../LICENSE
/////////////////////////////////////////////////////////////////////////////

/*

    There are several situations we need to deal with here:

    This could be a non-derived class (prop_use_derived_class is false) in which case the
    header file is empty, and we don't use the derived class name or derived filename
    even if specified.

    This could be a derived class, but either the class name or the filename is empty. In
    that case, we can't write to disk, but we can mockup a temporary class name if needed
    as well as a temporary filename.

    If we are trying to write to disk, we have to return result::exists if a non-derived
    class, result::ignored if filename or classname is empty.

*/

#include <array>
#include <thread>

#include "gen_cpp.h"

#include "code.h"              // Code -- Helper class for generating code
#include "eventhandler_dlg.h"  // EventHandlerDlg static functions
#include "node.h"              // Node class
#include "node_creator.h"      // NodeCreator class
#include "project_handler.h"   // ProjectHandler class
#include "write_code.h"        // Write code to Scintilla or file

#include "wxue_namespace/wxue_string.h"         // wxue::string
#include "wxue_namespace/wxue_string_vector.h"  // wxue::StringVector

// clang-format off

inline constexpr const auto txt_DerivedCmtBlock =
R"===(////////////////////////////////////////////////////////////////////////////
// Original Code generated by wxUiEditor
//
// The code is generated only once. You can now modify the code as needed.
////////////////////////////////////////////////////////////////////////////

)===";

static constexpr auto lst_close_type_button = std::to_array<const char*>({
    // Buttons that would normally be used to close the dialog need to call event.Skip() to get
    // validator data and to close the dialog.
    "OKButtonClicked",
    "YesButtonClicked",
    "SaveButtonClicked",
});

// clang-format on

auto CppCodeGenerator::GenerateDerivedClass(Node* project, Node* form, PANEL_PAGE panel_type) -> int
{
    m_form_node = form;
    m_is_derived_class = m_form_node->as_bool(prop_use_derived_class);

    wxue::string source_ext;
    wxue::string header_ext;
    GetFileExtensions(project, source_ext, header_ext);

    auto derived_file = DetermineDerivedFilePath(form, panel_type, source_ext);
    if (derived_file.empty() && panel_type == PANEL_PAGE::NOT_PANEL)
    {
        return result::exists;
    }

    // Caution! Don't return until thrd_get_events.join(); is called.
    EventVector events;
    std::thread thrd_get_events(&CppCodeGenerator::CollectEventHandlers, this, m_form_node,
                                std::ref(events));

    wxue::string baseFile;
    DetermineBaseFilePath(form, baseFile);

    wxue::string namespace_using_name;
    ProcessNamespace(form, namespace_using_name);

    wxue::string derived_name;
    GenerateDerivedClassName(derived_name);

    m_header->Clear();
    m_source->Clear();

    GenerateDerivedHeader(derived_name, baseFile, namespace_using_name, header_ext, panel_type);
    GenerateDerivedSource(project, derived_name, baseFile, derived_file, namespace_using_name,
                          header_ext, source_ext, panel_type);

    thrd_get_events.join();
    GenerateDerivedEventHandlers(events, derived_name, panel_type);

    m_header->Unindent();
    m_header->writeLine("};");

    return result::created;
}

// Helper method implementations

void CppCodeGenerator::GetFileExtensions(Node* project, wxue::string& source_ext,
                                         wxue::string& header_ext)
{
    source_ext = ".cpp";
    header_ext = ".h";

    if (const auto& extProp = project->as_string(prop_source_ext); extProp.size())
    {
        source_ext = extProp;
    }

    if (const auto& extProp = project->as_string(prop_header_ext); extProp.size())
    {
        header_ext = extProp;
    }
}

auto CppCodeGenerator::DetermineDerivedFilePath(Node* form, PANEL_PAGE panel_type,
                                                const wxue::string& source_ext) -> wxue::string
{
    wxue::string derived_file;

    if (m_is_derived_class && m_form_node->HasValue(prop_derived_file))
    {
        derived_file = Project.get_BaseDirectory(form, GEN_LANG_CPLUSPLUS);
        if (derived_file.size())
        {
            derived_file.append_filename(m_form_node->as_string(prop_derived_file));
        }
        else
        {
            derived_file = m_form_node->as_string(prop_derived_file);
        }

        derived_file.make_absolute();
        derived_file.backslashestoforward();
    }
    else
    {
        // If we're writing to disk, return empty to signal "exists"
        if (panel_type == PANEL_PAGE::NOT_PANEL)
        {
            return {};
        }
    }

    if (m_is_derived_class && panel_type == PANEL_PAGE::NOT_PANEL)
    {
        if (derived_file.empty())
        {
            return {};
        }

        derived_file.replace_extension(source_ext);

        if (derived_file.file_exists())
        {
            return {};  // We never allow writing over an existing derived class file
        }

        derived_file.remove_extension();
    }

    return derived_file;
}

void CppCodeGenerator::DetermineBaseFilePath(Node* form, wxue::string& baseFile)
{
    if (const auto& file = m_form_node->as_string(prop_base_file); file.size())
    {
        baseFile = Project.get_BaseDirectory(form, GEN_LANG_CPLUSPLUS);
        if (baseFile.size())
        {
            baseFile.append_filename(file);
        }
        else
        {
            baseFile = file;
        }

        baseFile.make_absolute();
        baseFile.backslashestoforward();
        baseFile.remove_extension();
    }
}

void CppCodeGenerator::ProcessNamespace(Node* form, wxue::string& namespace_using_name)
{
    // Make a copy of the string so that we can tweak it
    wxue::string namespace_prop = form->HasValue(prop_name_space) ?
                                      form->as_string(prop_name_space) :
                                      Project.as_string(prop_name_space);
    if (auto* node_namespace = form->get_Folder();
        node_namespace && node_namespace->HasValue(prop_folder_namespace))
    {
        namespace_prop = node_namespace->as_string(prop_folder_namespace);
    }

    if (namespace_prop.size())
    {
        // wxue::StringVector works with a single char, not a string.
        namespace_prop.Replace("::", ":");
        // we also accept using semi-colons to separate the namespaces
        namespace_prop.Replace(";", ":");

        wxue::StringVector names(namespace_prop, ':');
        for (auto& iter: names)
        {
            if (namespace_using_name.size())
            {
                namespace_using_name += "::";
            }
            namespace_using_name += iter;
        }
    }
}

void CppCodeGenerator::GenerateDerivedClassName(wxue::string& derived_name)
{
    derived_name = m_form_node->as_string(prop_derived_class_name);
    if (!m_is_derived_class)
    {
        // If this is not a derived class, then use the base class name
        derived_name = m_form_node->as_string(prop_class_name);
    }
    else if (derived_name.empty())
    {
        wxue::string base_name(m_form_node->as_string(prop_class_name));
        base_name.Replace("My", "");
        base_name.Replace("Base", "");
        derived_name << "MyDerived" << base_name;
    }
}

void CppCodeGenerator::GenerateDerivedHeader(const wxue::string& derived_name,
                                             const wxue::string& baseFile,
                                             const wxue::string& namespace_using_name,
                                             const wxue::string& header_ext, PANEL_PAGE panel_type)
{
    if (panel_type == PANEL_PAGE::SOURCE_PANEL)
    {
        return;
    }

    if (!m_is_derived_class)
    {
        m_header->writeLine("\n// No header needed when not creating a derived class\n// "
                            "(use_derived_class property is unchecked)");
        return;
    }

    m_header->writeLine(txt_DerivedCmtBlock);
    m_header->writeLine("\n#pragma once");
    m_header->writeLine();

    if (baseFile.empty())
    {
        m_header->writeLine("// Specify the filename to use in the base_file property");
        m_header->writeLine("#include \"Your filename here\"");
    }
    else
    {
        wxue::string base_with_ext(baseFile);
        base_with_ext.replace_extension(header_ext);
        m_header->writeLine(wxue::string("include ") << '"' << base_with_ext << '"');
    }
    m_header->writeLine();

    wxue::string line;
    line << "class " << derived_name << " : public ";
    if (namespace_using_name.size())
    {
        line << namespace_using_name << "::";
    }
    line << m_form_node->get_NodeName();

    m_header->writeLine(line);
    m_header->writeLine("{");

    m_header->writeLine("public:");
    m_header->Indent();

    m_header->writeLine(wxue::string()
                        << derived_name
                        << "();  // If you use this constructor, you must call Create(parent)");
    m_header->writeLine(wxue::string() << derived_name << "(wxWindow* parent);");

    m_header->Unindent();
}

void CppCodeGenerator::GenerateDerivedSource(Node* project, const wxue::string& derived_name,
                                             const wxue::string& baseFile,
                                             const wxue::string& derived_file,
                                             const wxue::string& namespace_using_name,
                                             const wxue::string& header_ext,
                                             const wxue::string& source_ext, PANEL_PAGE panel_type)
{
    if (panel_type == PANEL_PAGE::HDR_INFO_PANEL)
    {
        return;
    }

    if (m_is_derived_class)
    {
        m_source->writeLine(txt_DerivedCmtBlock);
    }

    if (const auto& prop = project->as_string(prop_local_pch_file); prop.size())
    {
        wxue::string pch("#include ");
        pch << "\"" << prop << "\"";

        m_source->writeLine();
        m_source->writeLine(pch);
        m_source->writeLine();
    }

    if (project->HasValue(prop_src_preamble))
    {
        wxue::string convert(project->as_string(prop_src_preamble));
        convert.Replace("@@", "\n", wxue::REPLACE::all);
        wxue::StringVector lines(convert, '\n');
        bool initial_bracket = false;
        for (auto& code: lines)
        {
            if (code.contains("}"))
            {
                m_source->Unindent();
            }
            else if (!initial_bracket && code.contains("["))
            {
                initial_bracket = true;
                m_source->Indent();
            }

            m_source->writeLine(code, indent::auto_no_whitespace);

            if (code.contains("{"))
            {
                m_source->Indent();
            }
        }
        m_source->Unindent();
        m_source->writeLine();
    }

    if (m_is_derived_class)
    {
        if (derived_file.empty())
        {
            m_source->writeLine();
            m_source->writeLine("// Specify the filename to use in the derived_file property");
            m_source->writeLine("#include \"Your filename here\"");
        }
        else
        {
            wxue::string inc;
            wxue::string base_copy(baseFile);
            wxue::string derived_copy(derived_file);

            // Add a comment to the header that specifies the generated header and source
            // filenames
            base_copy.replace_extension(header_ext);
            derived_copy.replace_extension(header_ext);
            inc << "include \"" << derived_copy.filename() << "\"";

            wxue::string comment(wxue::string(header_ext) << "\"  // auto-generated: ");
            comment << base_copy << " and ";
            base_copy.replace_extension(source_ext);
            comment << base_copy;
            inc.Replace(wxue::string(header_ext) << '"', comment);

            if (header_ext != ".h")
            {
                inc.Replace(".h", header_ext);
            }
            m_source->writeLine();
            m_source->writeLine(inc);
        }

        m_source->writeLine();
    }
    else
    {
        if (baseFile.empty())
        {
            m_source->writeLine();
            m_source->writeLine("// Specify the filename to use in the base_file property");
            m_source->writeLine("#include \"Your filename here\"");
        }
        else
        {
            wxue::string base_copy(baseFile);
            base_copy.replace_extension(header_ext);
            wxue::string inc;
            inc << "include \"" << base_copy << "\"";
            m_source->writeLine(
                "// Non-generated additions to base class (virtual events is unchecked)");
            m_source->writeLine("// Copy and paste into your own code as needed.");
            m_source->writeLine();
            m_source->writeLine(inc);
            m_source->writeLine();
        }
    }

    if (namespace_using_name.size())
    {
        m_source->writeLine(wxue::string() << "using namespace " << namespace_using_name << ';');
        m_source->writeLine();
    }

    if (m_is_derived_class)  // non-derived class doesn't have a constructor
    {
        wxue::string code;
        if (m_form_node->is_Gen(gen_wxDialog))
        {
            code << "// If this constructor is used, the caller must call Create(parent)\n";
            code << derived_name << "::" << derived_name << "() {}\n\n";
            code << derived_name << "::" << derived_name
                 << "(wxWindow* parent) { Create(parent); }";
        }
        else
        {
            code << derived_name << "::" << derived_name << "(wxWindow* parent) : ";
            code << m_form_node->get_NodeName() << "(parent) {}";
        }

        m_source->writeLine(code);
    }
}

void CppCodeGenerator::GenerateDerivedEventHandlers(const EventVector& events,
                                                    const wxue::string& derived_name,
                                                    PANEL_PAGE panel_type)
{
    if (events.empty())
    {
        return;
    }

    m_header->Unindent();
    m_header->writeLine();
    m_header->writeLine("protected:");
    m_header->Indent();
    m_header->SetLastLineBlank();
    m_header->writeLine(wxue::string()
                        << "// Handlers for " << m_form_node->get_NodeName() << " events");

    std::set<std::string> generatedHandlers;
    for (auto* event: events)
    {
        auto event_code = EventHandlerDlg::GetCppValue(event->get_value());
        // Ignore lambda's and functions in another class
        if (event_code.find('[') != std::string::npos || event_code.find("::") != std::string::npos)
        {
            continue;
        }

        if (!generatedHandlers.contains(event_code))
        {
            auto event_class = event->get_EventInfo()->get_event_class();
            bool close_type_button = IsCloseTypeButton(event);

            WriteEventHandlerDeclaration(event_code, event_class);

            if (panel_type != PANEL_PAGE::HDR_INFO_PANEL)
            {
                if (ShouldSkipContextMenuEvent(event))
                {
                    continue;
                }

                WriteEventHandlerImplementation(event, derived_name, event_code, close_type_button);
            }

            generatedHandlers.insert(event_code);
        }
    }
}

auto CppCodeGenerator::IsCloseTypeButton(NodeEvent* event) -> bool
{
    return std::ranges::any_of(lst_close_type_button,
                               [event](const auto& button_name)
                               {
                                   return event->get_EventInfo()->get_name().is_sameas(button_name);
                               });
}

auto CppCodeGenerator::ShouldSkipContextMenuEvent(NodeEvent* event) -> bool
{
    if (!event->getNode()->is_Form() || event->get_name() != "wxEVT_CONTEXT_MENU")
    {
        return false;
    }

    // Base class handles this event if any child is a context menu event
    return std::ranges::any_of(event->getNode()->get_ChildNodePtrs(),
                               [](const auto& child)
                               {
                                   return child->is_Gen(gen_wxContextMenuEvent);
                               });
}

void CppCodeGenerator::WriteEventHandlerDeclaration(const wxue::string& event_code,
                                                    const wxue::string& event_class)
{
    m_header->writeLine(wxue::string("void ")
                        << event_code << '(' << event_class << "& event) override;");
}

void CppCodeGenerator::WriteEventHandlerImplementation(NodeEvent* event,
                                                       const wxue::string& derived_name,
                                                       const wxue::string& event_code,
                                                       bool close_type_button)
{
    auto event_class = event->get_EventInfo()->get_event_class();
    m_source->writeLine();
    m_source->writeLine(wxue::string() << "void " << derived_name << "::" << event_code << '('
                                       << event_class << "& /* event unused */)");
    m_source->writeLine("{");
    m_source->Indent();

    auto name = event->get_EventInfo()->get_name();
    if (name == "wxEVT_INIT_DIALOG")
    {
        m_source->writeLine("event.Skip();  // transfer all validator data to "
                            "their windows and update UI");
    }
    else if (close_type_button)
    {
        Code code(m_form_node, GEN_LANG_CPLUSPLUS);
        code.Str("if (!Validate() || !TransferDataFromWindow())");
        code.OpenBrace();
        code.Str("return;");
        code.CloseBrace();

        code.Eol().Eol(eol_always).Str("if (IsModal())");
        code.OpenBrace();
        code.Str("EndModal(wxID_OK);");
        code.CloseBrace();

        code.Eol().Str("else");
        code.OpenBrace();
        code.Str("SetReturnCode(wxID_OK);");
        code.Eol().Str("Show(false);");
        code.CloseBrace();
        m_source->writeLine(code);

        if (m_form_node->as_bool(prop_persist))
        {
            m_source->writeLine();
            m_source->writeLine("event.Skip();  // This must be called for "
                                "wxPersistenceManager to work");
        }
    }
    else
    {
        m_source->writeLine(wxue::string("    // TODO: Implement ") << event_code,
                            indent::auto_no_whitespace);
    }

    m_source->Unindent();
    m_source->writeLine("}");
}
