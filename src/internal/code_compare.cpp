///////////////////////////////////////////////////////////////////////////////
// Code generated by wxUiEditor - see https://github.com/KeyWorksRW/wxUiEditor/
//
// Do not edit any code above the "End of generated code" comment block.
// Any changes before that block will be lost if it is re-generated!
///////////////////////////////////////////////////////////////////////////////

// clang-format off

#include <wx/sizer.h>
#include <wx/stattext.h>

#include "code_compare.h"

#include "../internal/WinMerge.xpm"

bool CodeCompare::Create(wxWindow* parent, wxWindowID id, const wxString& title,
    const wxPoint& pos, const wxSize& size, long style, const wxString &name)
{
    if (!wxDialog::Create(parent, id, title, pos, size, style, name))
        return false;

    auto* dlg_sizer = new wxBoxSizer(wxVERTICAL);

    auto* box_sizer = new wxBoxSizer(wxVERTICAL);

    auto* staticText_2 = new wxStaticText(this, wxID_ANY,
        "If you have WinMergeU.exe installed, and you have previously generated classes, then you can use this to compare what would be generated now. This can be helpful if you need to confirm code generation changes without having to actually write out the code.\n");
    staticText_2->Wrap(320);
    box_sizer->Add(staticText_2, wxSizerFlags().Border(wxLEFT|wxRIGHT|wxTOP, wxSizerFlags::GetDefaultBorder()));

    auto* grid_sizer = new wxGridSizer(3, 0, 0);

    m_radio_cplusplus = new wxRadioButton(this, wxID_ANY, "&C++", wxDefaultPosition, wxDefaultSize, wxRB_GROUP);
    grid_sizer->Add(m_radio_cplusplus, wxSizerFlags().Border(wxALL));

    m_radio_python = new wxRadioButton(this, wxID_ANY, "&Python");
    grid_sizer->Add(m_radio_python, wxSizerFlags().Border(wxALL));

    m_radio_ruby = new wxRadioButton(this, wxID_ANY, "&Ruby");
    grid_sizer->Add(m_radio_ruby, wxSizerFlags().Border(wxALL));

    m_radio_fortran = new wxRadioButton(this, wxID_ANY, "&Fortran");
    grid_sizer->Add(m_radio_fortran, wxSizerFlags().Border(wxALL));

    m_radio_haskell = new wxRadioButton(this, wxID_ANY, "&Haskell");
    grid_sizer->Add(m_radio_haskell, wxSizerFlags().Border(wxALL));

    m_radio_lua = new wxRadioButton(this, wxID_ANY, "&Lua");
    grid_sizer->Add(m_radio_lua, wxSizerFlags().Border(wxALL));

    m_radio_perl = new wxRadioButton(this, wxID_ANY, "&Perl");
    grid_sizer->Add(m_radio_perl, wxSizerFlags().Border(wxALL));

    m_radio_rust = new wxRadioButton(this, wxID_ANY, "R&ust");
    grid_sizer->Add(m_radio_rust, wxSizerFlags().Border(wxALL));

    m_radio_xrc = new wxRadioButton(this, wxID_ANY, "&XRC");
    grid_sizer->Add(m_radio_xrc, wxSizerFlags().Border(wxALL));

    box_sizer->Add(grid_sizer, wxSizerFlags().Center().Border(wxALL));

    box_sizer->AddSpacer(15);

    auto* staticText = new wxStaticText(this, wxID_ANY, "C&hanged Classes:");
    box_sizer->Add(staticText, wxSizerFlags().Border(wxALL));

    m_list_changes = new wxListBox(this, wxID_ANY);
    m_list_changes->Enable(false);
    m_list_changes->SetMinSize(FromDIP(wxSize(250, 200)));
    box_sizer->Add(m_list_changes, wxSizerFlags().Expand().Border(wxALL));

    m_btn = new wxButton(this, wxID_ANY, "&WinMerge...");
        m_btn->SetBitmap(wxBitmapBundle::FromBitmap(wxImage(WinMerge_xpm)));
    m_btn->Enable(false);
    box_sizer->Add(m_btn, wxSizerFlags().Border(wxALL));

    dlg_sizer->Add(box_sizer, wxSizerFlags().Border(wxALL));

    auto* stdBtn = CreateStdDialogButtonSizer(wxCLOSE|wxNO_DEFAULT);
    stdBtn->GetCancelButton()->SetDefault();
    dlg_sizer->Add(CreateSeparatedSizer(stdBtn), wxSizerFlags().Expand().Border(wxALL));

    if (pos != wxDefaultPosition)
    {
        SetPosition(FromDIP(pos));
    }
    if (size == wxDefaultSize)
    {
        SetSizerAndFit(dlg_sizer);
    }
    else
    {
        SetSizer(dlg_sizer);
        if (size.x == wxDefaultCoord || size.y == wxDefaultCoord)
        {
            Fit();
        }
        SetSize(FromDIP(size));
        Layout();
    }
    Centre(wxBOTH);

    // Event handlers
    m_btn->Bind(wxEVT_BUTTON, &CodeCompare::OnWinMerge, this);
    Bind(wxEVT_INIT_DIALOG, &CodeCompare::OnInit, this);
    m_radio_cplusplus->Bind(wxEVT_RADIOBUTTON, &CodeCompare::OnCPlusPlus, this);
    m_radio_fortran->Bind(wxEVT_RADIOBUTTON, &CodeCompare::OnFortran, this);
    m_radio_haskell->Bind(wxEVT_RADIOBUTTON, &CodeCompare::OnHaskell, this);
    m_radio_lua->Bind(wxEVT_RADIOBUTTON, &CodeCompare::OnLua, this);
    m_radio_perl->Bind(wxEVT_RADIOBUTTON, &CodeCompare::OnPerl, this);
    m_radio_python->Bind(wxEVT_RADIOBUTTON, &CodeCompare::OnPython, this);
    m_radio_ruby->Bind(wxEVT_RADIOBUTTON, &CodeCompare::OnRuby, this);
    m_radio_rust->Bind(wxEVT_RADIOBUTTON, &CodeCompare::OnRust, this);
    m_radio_xrc->Bind(wxEVT_RADIOBUTTON, &CodeCompare::OnXRC, this);

    return true;
}

// ************* End of generated code ***********
// DO NOT EDIT THIS COMMENT BLOCK!
//
// Code below this comment block will be preserved
// if the code for this class is re-generated.
//
// clang-format on
// ***********************************************

/////////////////// Non-generated Copyright/License Info ////////////////////
// Purpose:   Compare code generation
// Author:    Ralph Walden
// Copyright: Copyright (c) 2021-2023 KeyWorks Software (Ralph Walden)
// License:   Apache License -- see ../../LICENSE
/////////////////////////////////////////////////////////////////////////////

#include <wx/dir.h>  // wxDir is a class for enumerating the files in a directory

#include "gen_base.h"         // BaseCodeGenerator -- Generate Src and Hdr files for Base Class
#include "gen_common.h"       // Common code generation functions
#include "gen_results.h"      // Code generation file writing functions
#include "mainframe.h"        // MainFrame -- Main window frame
#include "node.h"             // Node class
#include "project_handler.h"  // ProjectHandler class

#include "pugixml.hpp"

// clang-format on

CodeCompare::~CodeCompare()
{
    wxDir dir;
    wxArrayString files;

    // Some project files will be placed in a subdirectory which will be our current cwd.
    // However, the actual generated files can be pretty much anywhere. In the following, we
    // check to see if the parent directory is named "src" and if so, we change to the parent
    // directory. This allows us to find the generated files no matter where they are located,
    // or at least as long as they were generated under the src/ directory.
    tt_cwd cwd(tt_cwd::restore);
    cwd.remove_filename();
    if (cwd.size() && (cwd.back() == '\\' || cwd.back() == '/'))
    {
        cwd.pop_back();
    }
    if (cwd.filename() == "src")
    {
        cwd.ChangeDir("..");
    }

    dir.GetAllFiles(".", &files, "~wxue_**.*");

    for (auto& iter: files)
    {
        // ~wxue_.WinMerge will often be added to this list, but deleted before we start
        // processing, so check first
        if (wxFileExists(iter))
        {
            wxRemoveFile(iter);
        }
    }

    if (Project.hasValue(prop_base_directory))
    {
        dir.GetAllFiles(Project.as_string(prop_base_directory).make_wxString(), &files, "~wxue_**.*");

        for (auto& iter: files)
        {
            // ~wxue_.WinMerge will often be added to this list, but deleted before we start processing, so check first
            if (wxFileExists(iter))
            {
                wxRemoveFile(iter);
            }
        }
    }
}

void CodeCompare::OnInit(wxInitDialogEvent& /* event */)
{
    GenLang language = Project.getCodePreference(wxGetFrame().getSelectedNode());
    wxCommandEvent dummy;
    switch (language)
    {
        case GEN_LANG_PYTHON:
            m_radio_python->SetValue(true);
            OnPython(dummy);
            break;
        case GEN_LANG_RUBY:
            m_radio_ruby->SetValue(true);
            OnRuby(dummy);
            break;
        case GEN_LANG_CPLUSPLUS:
        default:
            m_radio_cplusplus->SetValue(true);
            OnCPlusPlus(dummy);
            break;
    }
}

void CodeCompare::OnRadioButton(GenLang language)
{
    GenResults results;

    m_class_list.clear();
    m_list_changes->Clear();
    m_btn->Enable(false);

    bool result = false;
    switch (language)
    {
        case GEN_LANG_CPLUSPLUS:
            result = GenerateCppFiles(results, &m_class_list);
            break;
        case GEN_LANG_PERL:
            result = GenerateLanguageFiles(results, &m_class_list, GEN_LANG_PERL);
            break;
        case GEN_LANG_PYTHON:
            result = GenerateLanguageFiles(results, &m_class_list, GEN_LANG_PYTHON);
            break;
        case GEN_LANG_RUBY:
            result = GenerateLanguageFiles(results, &m_class_list, GEN_LANG_RUBY);
            break;
        case GEN_LANG_RUST:
            result = GenerateLanguageFiles(results, &m_class_list, GEN_LANG_RUST);
            break;
        case GEN_LANG_XRC:
            result = GenerateXrcFiles(results, {}, &m_class_list);
            break;

#if GENERATE_NEW_LANG_CODE
        case GEN_LANG_FORTRAN:
            result = GenerateLanguageFiles(results, &m_class_list, GEN_LANG_FORTRAN);
            break;
        case GEN_LANG_HASKELL:
            result = GenerateLanguageFiles(results, &m_class_list, GEN_LANG_HASKELL);
            break;
        case GEN_LANG_LUA:
            result = GenerateLanguageFiles(results, &m_class_list, GEN_LANG_LUA);
            break;
#endif  // GENERATE_NEW_LANG_CODE

        default:
            FAIL_MSG(tt_string() << "Unknown language: " << language);
            break;
    }

    if (result)
    {
        for (auto& iter: m_class_list)
        {
            m_list_changes->AppendString(iter.make_wxString());
        }
        m_btn->Enable();
    }
}

void CodeCompare::OnCPlusPlus(wxCommandEvent& /* event */)
{
    OnRadioButton(GEN_LANG_CPLUSPLUS);
}

void CodeCompare::OnPython(wxCommandEvent& /* event */)
{
    OnRadioButton(GEN_LANG_PYTHON);
}

void CodeCompare::OnRuby(wxCommandEvent& WXUNUSED(event))
{
    OnRadioButton(GEN_LANG_RUBY);
}

void CodeCompare::OnFortran(wxCommandEvent& WXUNUSED(event))
{
    OnRadioButton(GEN_LANG_FORTRAN);
}

void CodeCompare::OnHaskell(wxCommandEvent& /* event */)
{
    OnRadioButton(GEN_LANG_HASKELL);
}

void CodeCompare::OnLua(wxCommandEvent& /* event */)
{
    OnRadioButton(GEN_LANG_LUA);
}

void CodeCompare::OnPerl(wxCommandEvent& /* event */)
{
    OnRadioButton(GEN_LANG_PERL);
}

void CodeCompare::OnRust(wxCommandEvent& /* event */)
{
    OnRadioButton(GEN_LANG_RUST);
}

void CodeCompare::OnXRC(wxCommandEvent& /* event */)
{
    OnRadioButton(GEN_LANG_XRC);
}

// clang-format off

#if defined(_WIN32)

#include <windows.h>

// clang-format on

// Converts all text to UTF16 before calling ShellExecuteW(...)
HINSTANCE winShellRun(std::string_view filename, std::string_view args, std::string_view directory,
                      INT nShow = SW_SHOWNORMAL, HWND hwndParent = NULL);

HINSTANCE winShellRun(std::string_view filename, std::string_view args, std::string_view dir, INT nShow, HWND hwndParent)
{
    std::wstring name16;
    tt::utf8to16(filename, name16);
    std::wstring args16;
    tt::utf8to16(args, args16);
    std::wstring dir16;
    tt::utf8to16(dir, dir16);

    return ShellExecuteW(hwndParent, NULL, name16.c_str(), args16.c_str(), dir16.c_str(), nShow);
}

void CodeCompare::OnWinMerge(wxCommandEvent& /* event */)
{
    pugi::xml_document doc;
    auto root = doc.append_child("project");

    GenLang language = GEN_LANG_CPLUSPLUS;
    if (m_radio_python->GetValue())
        language = GEN_LANG_PYTHON;
    else if (m_radio_ruby->GetValue())
        language = GEN_LANG_RUBY;

    GenerateTmpFiles(m_class_list, root, language);

    doc.save_file("~wxue_.WinMerge");

    // WinMergeU.exe typically is not in the system PATH, and as such, wxExecute won't be able to find it. ShellExecute will
    // find the registered location for the program.

    tt_cwd cwd;

    // /e -- terminate with escape
    // /u -- don't add files to MRU
    winShellRun("WinMergeU.exe", "/e /u ~wxue_.WinMerge", cwd.c_str());
}

#else

void CodeCompare::OnWinMerge(wxCommandEvent& /* event */)
{
    wxMessageBox("WinMerge is only supported on Windows.", "WinMerge Not Found", wxOK | wxICON_INFORMATION);
}

#endif  // _WIN32
