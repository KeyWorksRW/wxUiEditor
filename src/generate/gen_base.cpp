/////////////////////////////////////////////////////////////////////////////
// Purpose:   Generate Src and Hdr files for Base and Derived Class
// Author:    Ralph Walden
// Copyright: Copyright (c) 2020-2021 KeyWorks Software (Ralph Walden)
// License:   Apache License -- see ../../LICENSE
/////////////////////////////////////////////////////////////////////////////

#include "pch.h"

#include <unordered_set>

#include <wx/filename.h>  // wxFileName - encapsulates a file path

#include <ttcvector.h>   // cstrVector -- Vector of ttlib::cstr strings
#include <ttmultistr.h>  // multistr -- Breaks a single string into multiple strings
#include <ttstr.h>       // ttString, ttSaveCwd -- Enhanced version of wxString
#include <tttextfile.h>  // textfile -- Classes for reading and writing line-oriented files

#include "gen_base.h"

#include "gen_common.h"    // GeneratorLibrary -- Generator classes
#include "gen_inherit.h"   // Inherited class code generation
#include "mainapp.h"       // App -- Main application class
#include "node.h"          // Node class
#include "node_creator.h"  // NodeCreator class
#include "node_decl.h"     // NodeDeclaration class
#include "pjtsettings.h"   // ProjectSettings -- Hold data for currently loaded project
#include "uifuncs.h"       // Miscellaneous functions for displaying UI
#include "utils.h"         // Utility functions that work with properties
#include "write_code.h"    // Write code to Scintilla or file

// clang-format off

inline constexpr const auto txt_GetImgFromHdrFunction = R"===(
#include <wx/mstream.h>  // Memory stream classes

// Convert a data header file into a wxImage
static wxImage GetImgFromHdr(const unsigned char* data, size_t size_data)
{
    wxMemoryInputStream strm(data, size_data);
    wxImage image;
    image.LoadFile(strm);
    return image;
};
)===";

inline constexpr const auto txt_CommentBlock =
R"===(////////////////////////////////////////////////////////////////////////////
// Code generated by wxUiEditor -- see https://github.com/KeyWorksRW/wxUiEditor/
//
// DO NOT EDIT THIS FILE! Your changes will be lost if it is re-generated!
////////////////////////////////////////////////////////////////////////////

)===";

// clang-format on

extern std::unordered_set<std::string> set_wx_ids;

BaseCodeGenerator::BaseCodeGenerator() {}

void BaseCodeGenerator::GenerateBaseClass(Node* project, Node* form_node, PANEL_TYPE panel_type)
{
    m_panel_type = panel_type;

    m_header->Clear();
    m_source->Clear();

    m_header->writeLine(txt_CommentBlock);
    m_source->writeLine(txt_CommentBlock);

    ttlib::cstr file;
    if (auto base_file = form_node->get_value_ptr("base_file"); base_file)
    {
        ttSaveCwd cwd;
        ttlib::ChangeDir(wxGetApp().getProjectPath());
        file = *base_file;
        file.make_relative(wxGetApp().getProjectPath());
        file.backslashestoforward();
        file.remove_extension();

        m_baseFullPath = *base_file;
        m_baseFullPath.make_absolute();
        m_baseFullPath.remove_filename();
    }

    m_header->writeLine("#pragma once");
    m_header->writeLine();

    std::set<std::string> src_includes;
    std::set<std::string> hdr_includes;
    if (project->prop_as_string("help_provider") != "none")
        src_includes.insert("#include <wx/cshelp.h>");
    if (project->prop_as_bool("internationalize"))
        hdr_includes.insert("#include <wx/intl.h>");

    // This will almost always be needed, and it in turn includes a bunch of other files like string.h which are also
    // almost always needed.
    hdr_includes.insert("#include <wx/gdicmn.h>");

    CollectIncludes(form_node, src_includes, hdr_includes);

    EventVector events;
    CollectEventHandlers(form_node, events);
    if (events.size())
    {
        hdr_includes.insert("#include <wx/event.h>");
    }

    if (panel_type != CPP_PANEL)
    {
        // BUGBUG: [KeyWorks - 01-25-2021] Need to look for base_class_name property of all children, and add each name
        // as a forwarded class.

        for (auto& iter: hdr_includes)
        {
            m_header->writeLine((ttlib::cstr&) iter);
        }

        if (form_node->prop_has_value(txt_base_hdr_includes))
        {
            m_header->writeLine();
            ttlib::cstr text = form_node->prop_as_string(txt_base_hdr_includes);
            text.Replace("\\n", "\n", true);
            if (text.back() == '\n')
                text.erase(text.size() - 1, 1);
            m_header->writeLine(text);
        }
    }

    if (project->prop_has_value("local_pch_file"))
    {
        m_source->writeLine(ttlib::cstr() << "#include \"" << project->prop_as_string("local_pch_file") << '"');
        m_source->writeLine();
    }

    if (form_node->prop_as_bool("persist"))
    {
        src_includes.insert("#include <wx/persist.h>");
        src_includes.insert("#include <wx/persist/toplevel.h>");
    }

    m_artProvider = form_node->prop_as_string("icon").is_sameprefix("Art");
    if (!m_artProvider && form_node->prop_as_string("icon").is_sameprefix("XPM"))
    {
        src_includes.insert("#include <wx/icon.h>");
    }
    CheckForArtProvider(form_node);
    if (m_artProvider)
    {
        src_includes.insert("#include <wx/artprov.h>");
    }

    // Make certain there is a blank line before the the wxWidget #includes
    m_source->writeLine();

    for (auto& iter: src_includes)
    {
        m_source->writeLine((ttlib::cstr&) iter);
    }

    m_source->writeLine();

    if (project->HasValue(txt_src_preamble))
    {
        ttlib::cstr code = project->prop_as_string(txt_src_preamble);

        // The multi-line editor may have been used in which case there are escaped newlines and tabs -- we convert
        // those to the actual characters before generating the code. It's common with that editor to have a trailing
        // EOL -- so we remove that if needed.
        code.Replace("\\n", "\n", true);
        code.Replace("\\t", "\t", true);
        if (code.back() == '\n')
            code.erase(code.size() - 1, 1);
        m_source->writeLine(code);
        m_source->writeLine();
    }

    if (form_node->HasValue(txt_base_src_includes))
    {
        ttlib::cstr code = form_node->prop_as_string(txt_base_src_includes);

        // The multi-line editor may have been used in which case there are escaped newlines and tabs -- we convert
        // those to the actual characters before generating the code. It's common with that editor to have a trailing
        // EOL -- so we remove that if needed.
        code.Replace("\\n", "\n", true);
        code.Replace("\\t", "\t", true);
        if (code.back() == '\n')
            code.erase(code.size() - 1, 1);
        m_source->writeLine(code);
        m_source->writeLine();
    }

    ttlib::cstr header_ext(".h");

    if (auto extProp = project->get_value_ptr("header_ext"); extProp)
    {
        header_ext = *extProp;
    }

    file.replace_extension(header_ext);
    m_source->writeLine();
    m_source->writeLine(ttlib::cstr() << "#include \"" << file.filename() << "\"");
    m_source->writeLine();

    GenerateImageIncludes(form_node);

    // Make a copy of the string so that we can tweak it
    auto namespace_prop = project->prop_as_string("namespace");
    size_t indent = 0;
    ttlib::multistr names;
    if (namespace_prop.size())
    {
        // ttlib::multistr works with a single char, not a string.
        namespace_prop.Replace("::", ":");
        // we also accept using semi-colons to separate the namespaces
        namespace_prop.Replace(";", ":");
        names.SetString(namespace_prop, ':');
        ttlib::cstr using_name;
        m_header->writeLine();
        for (auto& iter: names)
        {
            m_header->writeLine(ttlib::cstr() << "namespace " << iter);
            m_header->writeLine("{");
            m_header->Indent();
            ++indent;

            if (using_name.empty())
            {
                using_name = "using namespace ";
            }
            else
            {
                using_name += "::";
            }
            using_name += iter;
        }
        m_header->SetLastLineBlank();

        if (using_name.size())
        {
            using_name << ';';
            m_source->writeLine(using_name);
        }
    }

    if (m_panel_type != CPP_PANEL)
        GenerateClassHeader(form_node, wxEmptyString, events);

    if (m_panel_type != HDR_PANEL)
    {
        GenPngLoadFunction(form_node);
        GenerateClassConstructor(form_node, events);
    }

    if (indent > 0)
    {
        while (indent > 0)
        {
            m_header->Unindent();
            m_header->writeLine(ttlib::cstr() << "} // namespace " << names[--indent]);
        }
        m_header->writeLine();
    }
}

void BaseCodeGenerator::GenSrcEventBinding(Node* node, const EventVector& events)
{
    ASSERT_MSG(events.size(), "GenSrcEventBinding() shouldn't be called if there are no events");
    if (events.empty())
    {
        return;
    }

    auto propName = node->get_prop_ptr(txt_class_name);
    if (!propName)
    {
        FAIL_MSG(ttlib::cstr("Missing \"name\" property in ") << node->GetClassName() << " class.");
        return;
    }

    auto class_name = propName->GetValue();
    if (class_name.empty())
    {
        FAIL_MSG("Node name cannot be null");
        return;
    }

    for (auto& iter: events)
    {
        if (auto generator = iter->GetNode()->GetNodeDeclaration()->GetGenerator(); generator)
        {
            if (auto result = generator->GenEvents(iter, class_name); result)
            {
                m_source->writeLine(result.value(), result.value().contains("\n") ? indent::auto_keep_whitespace :
                                                                                    indent::auto_no_whitespace);
            }
        }
    }
}

void BaseCodeGenerator::GenHdrEvents(const EventVector& events)
{
    if (events.size() > 0)
    {
        std::set<ttlib::cstr> code_lines;
        for (size_t i = 0; i < events.size(); i++)
        {
            auto& event = events[i];

            // Ignore lambda's and functions in another class
            if (event->get_value().contains("[") || event->get_value().contains("::"))
                continue;

            ttlib::cstr code;
            code << " virtual void " << event->get_value() << "(" << event->GetEventInfo()->get_event_class()
                 << "& event) { event.Skip(); }";
            code_lines.insert(code);
        }

        if (code_lines.size())
        {
            m_header->writeLine();
            m_header->writeLine("// Virtual event handlers -- override them in your derived class");
            m_header->writeLine();

            for (auto& iter: code_lines)
            {
                m_header->writeLine((ttlib::cstr&) (iter));
            }
        }
    }
}

void BaseCodeGenerator::CollectMemberVariables(Node* node, Permission perm, std::set<std::string>& code_lines)
{
    if (auto prop = node->get_value_ptr(txt_class_access); prop)
    {
        if (*prop != "none")
        {
            if ((perm == Permission::Public && *prop == "public:") ||
                (perm == Permission::Protected && *prop == "protected:"))
            {
                auto code = GetDeclaration(node);
                if (code.size())
                    code_lines.insert(code);
            }
        }

        if (perm == Permission::Protected)
        {
            // StaticCheckboxBoxSizer and StaticRadioBtnBoxSizer have internal variables
            if (node->prop_has_value("checkbox_var_name") || node->prop_has_value("radiobtn_var_name"))
            {
                auto code = GetDeclaration(node);
                if (code.size())
                    code_lines.insert(code);
            }
        }

        for (size_t i = 0; i < node->GetChildCount(); i++)
        {
            auto child = node->GetChild(i);
            CollectMemberVariables(child, perm, code_lines);
        }

        return;
    }

    for (size_t i = 0; i < node->GetChildCount(); i++)
    {
        auto child = node->GetChild(i);
        CollectMemberVariables(child, perm, code_lines);
    }
}

void BaseCodeGenerator::CollectValidatorVariables(Node* node, std::set<std::string>& code_lines)
{
    GenValVarsBase(node->GetNodeDeclaration(), node, code_lines);

    for (size_t i = 0; i < node->GetChildCount(); i++)
    {
        auto child = node->GetChild(i);
        CollectValidatorVariables(child, code_lines);
    }
}

void BaseCodeGenerator::GenValidatorFunctions(Node* node)
{
    if (node->HasValue("validator_variable"))
    {
        auto result = GenGetSetCode(node);
        if (result)
        {
            m_header->writeLine(result.value());
        }
    }

    for (size_t i = 0; i < node->GetChildCount(); i++)
    {
        auto child = node->GetChild(i);
        GenValidatorFunctions(child);
    }
}

void BaseCodeGenerator::GenValVarsBase(const NodeDeclaration* declaration, Node* node, std::set<std::string>& code_lines)
{
    if (auto var_name = node->get_value_ptr("validator_variable"); var_name && var_name->size())
    {
        // All validators must have a validator_data_type property, so we don't check if it exists.
        if (auto val_data_type = node->get_value_ptr("validator_data_type"); val_data_type->size())
        {
            ttlib::cstr code;

            code << *val_data_type << ' ' << *var_name;

            if (*val_data_type == "bool")
            {
                auto prop = node->get_prop_ptr("checked");
                bool bState = (prop && prop->as_bool());
                if (!prop)
                {
                    prop = node->get_prop_ptr("initial_state");
                    if (prop && prop->as_string() == "wxCHK_CHECKED")
                        bState = true;
                }
                code << " { " << (bState ? "true" : "false") << " };";
            }
            else if (*val_data_type == "int")
            {
                auto prop = node->get_prop_ptr(txt_value);
                if (!prop)
                    prop = node->get_prop_ptr("initial");
                if (!prop)
                    prop = node->get_prop_ptr("selection");
                if (prop && prop->as_string().size())
                {
                    code << " { " << prop->as_string() << " };";
                }
                else
                {
                    code << ';';
                }
            }
            else if (*val_data_type == "wxString" || *val_data_type == "wxFileName")
            {
                auto value = node->get_value_ptr(txt_value);
                if (value && value->size())
                {
                    code << " { " << GenerateQuotedString(*value) << " };";
                }
                else
                {
                    code << ';';
                }
            }
            else
            {
                code << ';';
            }

            code_lines.insert(code);
        }
    }

    for (size_t i = 0; i < declaration->GetBaseClassCount(false); i++)
    {
        GenValVarsBase(declaration->GetBaseClass(i, false), node, code_lines);
    }
}

void BaseCodeGenerator::CollectIncludes(Node* node, std::set<std::string>& set_src, std::set<std::string>& set_hdr)
{
    GatherGeneratorIncludes(node, set_src, set_hdr);

    // If an include in going to be generated in the header file, then don't also generate it in the src file.
    for (auto& iter: set_hdr)
    {
        auto pos = set_src.find(iter);
        if (pos != set_src.end())
            set_src.erase(pos);
    }

    // We special-case valgen.h and valtext.h because validators are only used in the source code, but things like
    // wxRadioBox will indicate that it requires it. Note the we add these any time a control is added that might have a
    // validator -- we don't actually check to see if the validator is being used. Since this only gets included in the
    // source file, the compile time impact of including it is negligible.

    if (auto pos = set_hdr.find("#include <wx/valgen.h>"); pos != set_hdr.end())
    {
        set_hdr.erase(pos);
        set_src.insert("#include <wx/valgen.h>");
    }

    if (auto pos = set_hdr.find("#include <wx/valtext.h>"); pos != set_hdr.end())
    {
        set_hdr.erase(pos);
        set_src.insert("#include <wx/valtext.h>");
    }
}

void BaseCodeGenerator::GatherGeneratorIncludes(Node* node, std::set<std::string>& set_src, std::set<std::string>& set_hdr)
{
    bool isAddToSrc = false;

    // If the component is set for local access only, then add the header file to the source set. Once all processing is
    // done, if this header was also used by a component with non-local access, then it will be removed from the source
    // set.
    if (auto prop = node->get_value_ptr(txt_class_access); prop && *prop == "none")
        isAddToSrc = true;

    auto generator = node->GetNodeDeclaration()->GetGenerator();
    generator->GetIncludes(node, set_src, set_hdr);
    if (node->prop_has_value("validator_variable"))
    {
        auto var_name = node->get_value_ptr("validator_variable");
        if (var_name && var_name->size())
        {
            set_hdr.insert("#include <wx/valgen.h>");
            auto validator_type = node->get_value_ptr("validator_type");
            if (validator_type && validator_type->is_sameas("wxTextValidator"))
                set_hdr.insert("#include <wx/valtext.h>");
            auto val_data_type = node->get_value_ptr("validator_data_type");
            if (val_data_type && *val_data_type == "wxArrayInt")
                set_hdr.insert("#include <wx/dynarray.h>");
        }
    }

    // A lot of widgets have wxWindow and/or wxAnyButton as derived classes, and those classes contain properties for
    // font, color, and bitmaps. If the property is used, then we add a matching header file.

    for (auto& iter: node->get_props_vector())
    {
        if (iter.HasValue())
        {
            if (iter.GetType() == Type::Wxfont)
            {
                if (isAddToSrc)
                {
                    set_src.insert("#include <wx/font.h>");
                }
                else
                {
                    set_hdr.insert("#include <wx/font.h>");
                }
            }
            else if (iter.GetType() == Type::Wxcolour)
            {
                if (isAddToSrc)
                {
                    set_src.insert("#include <wx/colour.h>");
                    set_src.insert("#include <wx/settings.h>");  // This is needed for the system colours
                }
                else
                {
                    set_hdr.insert("#include <wx/colour.h>");
                    set_hdr.insert("#include <wx/settings.h>");  // This is needed for the system colours
                }
            }
            else if (iter.GetType() == Type::Image)
            {
                // The problem at this point is that we don't know how the bitmap will be used. It could be just a
                // wxBitmap, or it could be handed to a wxImage for sizing, or it might be handed to
                // wxWindow->SetIcon(). We play it safe and supply all three header files.

                if (isAddToSrc)
                {
                    set_src.insert("#include <wx/bitmap.h>");
                    set_src.insert("#include <wx/icon.h>");
                    set_src.insert("#include <wx/image.h>");
                }
                else
                {
                    set_hdr.insert("#include <wx/bitmap.h>");
                    set_hdr.insert("#include <wx/icon.h>");
                    set_hdr.insert("#include <wx/image.h>");
                }
            }
        }
    }

    // Now parse all the children
    for (size_t i = 0; i < node->GetChildCount(); i++)
    {
        auto child = node->GetChild(i);
        GatherGeneratorIncludes(child, set_src, set_hdr);
    }
}

ttlib::cstr BaseCodeGenerator::GetDeclaration(Node* node)
{
    ttlib::cstr code;

    ttlib::cstr class_name = node->GetClassName();
    if (ttlib::is_sameprefix(class_name, "wx"))
    {
        code << class_name << "* " << node->get_node_name() << ';';
        if (class_name == "wxStdDialogButtonSizer")
        {
            if (node->prop_as_bool("OK"))
                code << "\n    wxButton* " << node->get_node_name() << "OK;";
            if (node->prop_as_bool("Yes"))
                code << "\n    wxButton* " << node->get_node_name() << "Yes;";
            if (node->prop_as_bool("Save"))
                code << "\n    wxButton* " << node->get_node_name() << "Save;";
            if (node->prop_as_bool("Apply"))
                code << "\n    wxButton* " << node->get_node_name() << "Apply;";
            if (node->prop_as_bool("No"))
                code << "\n    wxButton* " << node->get_node_name() << "No;";
            if (node->prop_as_bool("Cancel"))
                code << "\n    wxButton* " << node->get_node_name() << "Cancel;";
            if (node->prop_as_bool("Help"))
                code << "\n    wxButton* " << node->get_node_name() << "Help;";
            if (node->prop_as_bool("ContextHelp"))
                code << "\n    wxButton* " << node->get_node_name() << "ContextHelp;";
        }
        else if (class_name == "wxStaticBitmap")
        {
            // If scaling was specified, then we need to switch to wxGenericStaticBitmap in order to support it.
            if (node->prop_as_string("scale_mode") != "None")
                code.Replace("wxStaticBitmap", "wxGenericStaticBitmap");
        }
        return code;
    }

    else if (class_name == "StaticCheckboxBoxSizer")
    {
        if (node->prop_has_value("checkbox_var_name"))
            code << "wxCheckBox* " << node->prop_as_string("checkbox_var_name") << ';';

        if (!node->IsLocal())
        {
            if (code.size())
                code << "\n    ";
            code << "wxStaticBoxSizer* " << node->get_node_name() << ';';
        }
    }
    else if (class_name == "StaticRadioBtnBoxSizer")
    {
        if (node->prop_has_value("radiobtn_var_name"))
            code << "wxRadioButton* " << node->prop_as_string("radiobtn_var_name") << ';';

        if (!node->IsLocal())
        {
            if (code.size())
                code << "\n    ";
            code << "wxStaticBoxSizer* " << node->get_node_name() << ';';
        }
    }

    else if (class_name == "propGridItem")
    {
        code << "wxPGProperty* " << node->get_node_name() << ';';
    }
    else if (class_name == "propGridPage")
    {
        code << "wxPropertyGridPage* " << node->get_node_name() << ';';
    }
    else if (class_name == "submenu")
    {
        code << "wxMenu* " << node->get_node_name() << ';';
    }
    else if (class_name == "Check3State")
    {
        code << "wxCheckBox* " << node->get_node_name() << ';';
    }
    else if (class_name == "tool")
    {
        class_name = node->GetParent()->GetClassName();
        if (class_name == "wxAuiToolBar")
        {
            code << "wxAuiToolBarItem* " << node->get_node_name() << ';';
        }
        else if (class_name == "wxToolBar")
        {
            code << "wxToolBarToolBase* " << node->get_node_name() << ';';
        }
        else if (class_name == "ToolBar")
        {
            code << "wxToolBarToolBase* " << node->get_node_name() << ';';
        }
        else
        {
            FAIL_MSG("Unrecognized class name so no idea how to declare it in the header file.");
        }
    }

    return code;
}

void BaseCodeGenerator::GenerateClassHeader(Node* form_node, const wxString& classDecoration, const EventVector& events)
{
    auto propName = form_node->get_prop_ptr(txt_class_name);
    if (!propName)
    {
        FAIL_MSG(ttlib::cstr("Missing \"name\" property in ") << form_node->GetClassName());
        return;
    }

    auto class_name = propName->GetValue();
    if (class_name.empty())
    {
        FAIL_MSG("Node name can not be null");
        return;
    }

    auto generator = form_node->GetNodeDeclaration()->GetGenerator();

    // This may result in two blank lines, but without it there may be a case where there is no blank line at all.
    // Clang-format, if enabled would remove the extra blank line, but would not add the missing blank line.
    m_header->writeLine();

    if (auto result = generator->GenCode("base", form_node); result)
    {
        m_header->writeLine(ttlib::cstr() << "class " << classDecoration.wx_str() << class_name << " : " << result.value());
    }

    m_header->writeLine("{");
    m_header->writeLine("public:");
    m_header->Indent();
    m_header->SetLastLineBlank();

    // The set is used to prevent duplicates and to write the lines sorted. Call WriteSetLines() to write the lines and
    // clear the set.
    std::set<std::string> code_lines;
    CollectMemberVariables(form_node, Permission::Public, code_lines);
    if (code_lines.size())
    {
        WriteSetLines(m_header, code_lines);
        m_header->writeLine();
    }

    if (auto result = generator->GenCode("ctor_declare", form_node); result)
    {
        m_header->writeLine(result.value(), indent::auto_keep_whitespace);
    }
    m_header->SetLastLineBlank();

    GenValidatorFunctions(form_node);
    m_header->writeLine();

    GenEnumIds(form_node);

    m_header->Unindent();
    m_header->writeLine("protected:");
    m_header->Indent();

    CollectValidatorVariables(form_node, code_lines);
    if (code_lines.size())
    {
        m_header->writeLine();
        m_header->writeLine("// Validator variables");
        m_header->writeLine();
        WriteSetLines(m_header, code_lines);
    }

    CollectMemberVariables(form_node, Permission::Protected, code_lines);
    if (code_lines.size())
    {
        m_header->writeLine();
        m_header->writeLine("// Class member variables");
        m_header->writeLine();
        WriteSetLines(m_header, code_lines);
    }

    GenHdrEvents(events);

    m_header->Unindent();
    m_header->writeLine("};");
}

void BaseCodeGenerator::GenEnumIds(Node* class_node)
{
    std::set<std::string> set_ids;
    CollectIDs(class_node, set_ids);
    if (set_ids.empty())
        return;

    m_header->writeLine("enum");
    m_header->writeLine("{");
    m_header->Indent();

    size_t item = 0;
    for (auto& iter: set_ids)
    {
        m_header->write(iter);
        if (item == 0)
        {
            m_header->write(" = wxID_HIGHEST + 1", true);
        }

        if (item < set_ids.size() - 1)
        {
            m_header->writeLine(",");
        }
        ++item;
    }

    m_header->Unindent();
    m_header->writeLine();
    m_header->writeLine("};");
    m_header->writeLine();
}

void BaseCodeGenerator::GenerateClassConstructor(Node* form_node, const EventVector& events)
{
    m_source->writeLine();

    auto generator = form_node->GetNodeDeclaration()->GetGenerator();

    if (auto result = generator->GenConstruction(form_node); result)
    {
        m_source->writeLine(result.value(), indent::none);
    }
    m_source->Indent();

    size_t auto_indent = indent::auto_no_whitespace;
    if (auto result = generator->GenSettings(form_node, auto_indent); result)
    {
        if (result.value().size())
        {
            m_source->writeLine(result.value(), auto_indent);
            m_source->writeLine();
        }
    }

    if (form_node->get_prop_ptr("window_extra_style"))
    {
        ttlib::cstr code;
        GenerateWindowSettings(form_node, code);
        if (code.size())
            m_source->writeLine(code);
    }

    m_source->SetLastLineBlank();
    for (size_t i = 0; i < form_node->GetChildCount(); i++)
    {
        GenConstruction(form_node->GetChild(i));
    }

    if (auto result = generator->GenCode("after_addchild", form_node); result)
    {
        if (result.value().size())
        {
            m_source->writeLine();
            m_source->writeLine(result.value(), indent::none);
        }
    }

    if (form_node->prop_as_bool("persist"))
    {
        m_source->writeLine();
        m_source->writeLine(ttlib::cstr().Format("SetName(%ks);", form_node->get_node_name().c_str()));
        m_source->writeLine("wxPersistentRegisterAndRestore(this);");
    }

    if (events.size())
    {
        m_source->writeLine();
        m_source->writeLine("// Event handlers");
        GenSrcEventBinding(form_node, events);
    }

    m_source->Unindent();
    m_source->writeLine("}");
}

void BaseCodeGenerator::GenConstruction(Node* node)
{
    auto& type = node->GetNodeTypeName();
    auto declaration = node->GetNodeDeclaration();

    if (auto generator = declaration->GetGenerator(); generator)
    {
        if (auto result = generator->GenConstruction(node); result)
        {
            m_source->writeLine();

            // Some code generation may put added lines in a { } block, in which case we need to keep indents.
            m_source->writeLine(result.value(),
                                ttlib::is_found(result.value().find('{')) ? indent::none : indent::auto_no_whitespace);
        }
        GenSettings(node);

        if (type == "ribbontoolbar")
        {
            m_source->writeLine("{");
            m_source->Indent();
            // A wxRibbonToolBar can only have abstract children that consist of the tools.
            for (const auto& child: node->GetChildNodePtrs())
            {
                auto child_comp = child->GetNodeDeclaration()->GetGenerator();
                if (auto result = child_comp->GenConstruction(child.get()); result)
                    m_source->writeLine(result.value());
            }
            m_source->Unindent();
            m_source->writeLine("}");
            m_source->writeLine(ttlib::cstr() << node->get_node_name() << "->Realize();");
            return;
        }

        auto parent = node->GetParent();
        if (parent->IsSizer())
        {
            ttlib::cstr code;
            if (auto result = generator->GenCode("after_addchild", node); result)
            {
                if (result.value().size())
                    m_source->writeLine(result.value(), indent::none);
            }

            // Code for spacer's is handled by the component's GenConstruction() call
            if (node->GetClassName() != "spacer")
            {
                if (node->GetClassName() == "wxStdDialogButtonSizer")
                {
                    if (node->FindParentForm()->GetClassName() == "wxDialog" && node->prop_as_bool("static_line"))
                        code << node->GetParent()->get_node_name() << "->Add(CreateSeparatedSizer(" << node->get_node_name()
                             << "), ";
                    else
                        code << node->GetParent()->get_node_name() << "->Add(" << node->get_node_name() << ", ";
                }
                else
                {
                    code << node->GetParent()->get_node_name() << "->Add(" << node->get_node_name() << ", ";
                }

                if (parent->GetClassName() == "wxGridBagSizer")
                {
                    code << "wxGBPosition(" << node->prop_as_string(txt_row) << ", " << node->prop_as_string(txt_column)
                         << "), ";
                    code << "wxGBSpan(" << node->prop_as_string(txt_rowspan) << ", " << node->prop_as_string(txt_colspan)
                         << "), ";
                    if (node->prop_as_string(txt_borders).empty())
                        code << "0";
                    else
                        code << node->prop_as_string(txt_borders);
                    code << ", " << node->prop_as_string(txt_border_size) << ");";
                    code.Replace(", 0, 0);", ");");
                }
                else
                {
                    code << GenerateSizerFlags(node) << ");";
                }
            }

            m_source->writeLine(code);
        }
        else if (node->GetNodeType()->get_name() == "widget" && parent->GetClassName() == "wxChoicebook")
        {
            ttlib::cstr code;
            code << parent->get_node_name() << "->GetControlSizer()->Add(" << node->get_node_name();
            code << ", wxSizerFlags().Expand().Border(wxALL));";
            m_source->writeLine(code);
        }

        for (const auto& child: node->GetChildNodePtrs())
        {
            GenConstruction(child.get());
        }

        if (node->IsSizer())
        {
            if (!parent->IsSizer())
            {
                // The parent node is not a sizer -- which is expected if this is the parent sizer underneath a form or
                // wxPanel.

                ttlib::cstr code;
                if (GetParentName(node) != "this")
                    code << GetParentName(node) << "->";
                code << "SetSizerAndFit(" << node->get_node_name() << ");";

                m_source->writeLine();
                m_source->writeLine(code);
            }
        }
        else if (type == "splitter")
        {
            ttlib::cstr code(node->get_node_name());

            if (node->GetChildCount() == 1)
            {
                code << "->Initialize(" << node->GetChild(0)->get_node_name() << ");";
                m_source->writeLine(code);
            }
            else if (node->GetChildCount() > 1)
            {
                if (node->get_prop_ptr("splitmode")->GetValue() == "wxSPLIT_VERTICAL")
                    code << "->SplitVertically(";
                else
                    code << "->SplitHorizontally(";

                code << node->GetChild(0)->get_node_name() << ", " << node->GetChild(1)->get_node_name() << ");";
                m_source->writeLine(code);

                if (auto sash_pos = node->get_prop_ptr("sashpos")->as_int(); sash_pos != 0 && sash_pos != -1)
                {
                    code = node->get_node_name();
                    code << "->SetSashPosition(" << node->prop_as_string("sashpos") << ");";
                    m_source->writeLine(code);
                }
            }
        }
        else if (type == "menubar" || type == "menu" || type == "submenu" || type == "toolbar" || type == "tool" ||
                 type == "listbook" || type == "simplebook" || type == "notebook" || type == "auinotebook" ||
                 type == "treelistctrl")
        {
            if (auto result = generator->GenCode("after_addchild", node); result)
            {
                if (result.value().size())
                    m_source->writeLine(result.value(), indent::none);
            }
            m_source->writeLine();
        }
    }

    // A wxRibbonBar needs to be realized after all children have been created

    if (node->GetClassName() == "wxRibbonBar")
    {
        m_source->writeLine(ttlib::cstr() << node->get_node_name() << "->Realize();");
    }
}

void BaseCodeGenerator::CollectIDs(Node* node, std::set<std::string>& set_ids)
{
    for (auto& iter: node->get_props_vector())
    {
        if (iter.GetType() == Type::ID)
        {
            auto& prop_id = iter.GetValue();
            if (!prop_id.is_sameprefix("wxID_"))
                set_ids.insert(prop_id);
        }
    }

    for (auto& iter: node->GetChildNodePtrs())
    {
        CollectIDs(iter.get(), set_ids);
    }
}

void BaseCodeGenerator::CollectEventHandlers(Node* node, EventVector& events)
{
    for (size_t i = 0; i < node->GetEventCount(); i++)
    {
        auto event = node->GetEvent(i);
        if (!event->get_value().empty())
            events.push_back(event);
    }

    for (size_t i = 0; i < node->GetChildCount(); ++i)
    {
        auto child = node->GetChild(i);
        CollectEventHandlers(child, events);
    }
}

void BaseCodeGenerator::GenSettings(Node* node)
{
    size_t auto_indent = indent::auto_no_whitespace;
    auto generator = node->GetNodeDeclaration()->GetGenerator();

    if (auto result = generator->GenSettings(node, auto_indent); result)
    {
        if (result.value().size())
            m_source->writeLine(result.value(), auto_indent);
    }

    // If the node has a window_extra_style property, then generate any possible validator settings as
    // well as any window settings.

    if (node->get_prop_ptr("window_extra_style"))
    {
        ttlib::cstr code;
        if (auto result = GenInheritSettings(node); result)
        {
            m_source->writeLine(result.value());
        }

        GenerateWindowSettings(node, code);
        if (code.size())
            m_source->writeLine(code);
    }
}

void BaseCodeGenerator::GenerateImageIncludes(Node* node)
{
    std::set<std::string> include_set;
    CollectImageHeaders(node, include_set);

    if (include_set.empty())
    {
        return;
    }

    for (auto& iter: include_set)
    {
        m_source->writeLine(iter.c_str());
    }

    m_source->writeLine();
}

void BaseCodeGenerator::CollectImageHeaders(Node* node, std::set<std::string>& embedset)
{
    for (auto& iter: node->get_props_vector())
    {
        if (iter.GetType() == Type::Image)
        {
            if (!iter.HasValue())
                continue;
            auto& value = iter.as_string();
            if (value.is_sameprefix("Header") || value.is_sameprefix("XPM") || value.is_sameprefix("HDR"))
            {
                auto posBegin = value.stepover();
                auto posEnd = value.find(';', posBegin);
                ttlib::cstr path = value.substr(posBegin, posEnd - posBegin);
                path.make_relative(m_baseFullPath);
                path.backslashestoforward();
                ttlib::cstr inc;
                inc << "#include \"" << path << "\"";
                embedset.insert(inc);
                continue;
            }
        }
    }

    auto count = node->GetChildCount();
    for (size_t i = 0; i < count; i++)
    {
        auto child = node->GetChild(i);
        CollectImageHeaders(child, embedset);
    }
}

void BaseCodeGenerator::GenPngLoadFunction(Node* form_node)
{
    if (form_node->prop_as_string("icon").is_sameprefix("Header;") || FindHdrString(form_node))
    {
        ttlib::textfile function;
        function.ReadString(txt_GetImgFromHdrFunction);
        for (auto& iter: function)
        {
            m_source->writeLine(iter, indent::none);
        }
    }
}

bool BaseCodeGenerator::FindHdrString(Node* node)
{
    for (size_t i = 0; i < node->GetChildCount(); i++)
    {
        auto child = node->GetChild(i);
        auto description = child->prop_as_string("bitmap");
        if (description.size())
        {
            ttlib::multistr parts(description, BMP_PROP_SEPARATOR);
            for (auto& iter: parts)
            {
                iter.BothTrim();
            }

            if (parts[IndexType] == "Header" && parts[IndexImage].size())
            {
                if (!parts[IndexImage].contains(".xpm", tt::CASE::either))
                    return true;
            }
        }
        if (child->GetChildCount())
        {
            auto result = FindHdrString(child);
            if (result)
                return result;
        }
    }
    return false;
}

void BaseCodeGenerator::CheckForArtProvider(Node* node)
{
    for (size_t i = 0; i < node->GetChildCount(); i++)
    {
        auto child = node->GetChild(i);
        auto description = child->prop_as_string("bitmap");
        if (description.is_sameprefix("Art"))
        {
            m_artProvider = true;
            return;
        }

        if (child->GetChildCount())
            CheckForArtProvider(child);
    }
}

void BaseCodeGenerator::WriteSetLines(WriteCode* out, std::set<std::string>& code_lines)
{
    for (auto iter: code_lines)
    {
        // out->writeLine((ttlib::cstr&) (iter));
        out->writeLine(iter);
    }
    code_lines.clear();
}
