//////////////////////////////////////////////////////////////////////////
// Purpose:   Classs to write code to disk
// Author:    Ralph Walden
// Copyright: Copyright (c) 2020-2025 KeyWorks Software (Ralph Walden)
// License:   Apache License -- see ../../LICENSE
/////////////////////////////////////////////////////////////////////////////

#include <ranges>
#include <wx/file.h>      // wxFile - encapsulates low-level "file descriptor"
#include <wx/filename.h>  // wxFileName - encapsulates a file path
#include <wx/msgdlg.h>    // common header and base class for wxMessageDialog

#include "file_codewriter.h"

#include "code.h"            // Code -- Helper class for generating code
#include "common_strings.h"  // Common strings used in code generation
#include "gen_enums.h"
#include "mainapp.h"             // App -- Main application class
#include "ttwx_string_vector.h"  // tt_string_vector -- Read/Write line-oriented strings/files

using namespace code;

// clang-format off

inline constexpr std::string_view end_cpp_block =
R"===(
// ************* End of generated code ***********
// DO NOT EDIT THIS COMMENT BLOCK!
//
// Code below this comment block will be preserved
// if the code for this class is re-generated.
//
// clang-format on
// ***********************************************
)===";

inline constexpr const auto end_python_perl_ruby_block =
R"===(# ************* End of generated code ***********
# DO NOT EDIT THIS COMMENT BLOCK!
#
# Code below this comment block will be preserved
# if the code for this class is re-generated.
# ***********************************************
)===";

// clang-format on

const std::string_view cpp_end_cmt_line = "// ************* End of generated code";

auto FileCodeWriter::WriteFile(GenLang language, int flags, Node* node) -> int
{
    ASSERT_MSG(!m_filename.GetFullPath().IsEmpty(),
               "Filename must be set before calling WriteFile()");

    // Initialize member variables
    m_node = node;
    m_language = language;
    m_flags = flags;
    m_file_exists = m_filename.FileExists();
    m_block_length = GetBlockLength(language);
    m_additional_content = (to_size_t) -1;
    m_comment_line_to_find = GetCommentLineToFind(language);

    if (!m_file_exists && (flags & flag_test_only))
    {
        return write_needed;
    }

    bool is_comparing = (!m_filename.GetName().IsEmpty() && m_filename.GetName()[0] == '~');

    if (m_file_exists || is_comparing)
    {
        int read_error = ReadOriginalFile(is_comparing);
        if (read_error != 0)
        {
            return read_error;
        }

        // Create m_new_file once to check for additional content
        m_new_file.ReadString(std::string_view(m_buffer));
        m_additional_content = FindAdditionalContentIndex();
    }

    // Append end of file block with additional content information
    AppendEndOfFileBlock();

    if (m_file_exists || is_comparing)
    {
        // Update m_new_file with the appended end-of-file block
        m_new_file.ReadString(std::string_view(m_buffer));
        ProcessExistingFile();

        if (m_additional_content == write_current)
        {
            return write_current;
        }

        if (m_additional_content == write_needed && (flags & flag_test_only))
        {
            return write_needed;
        }
    }

    if (flags & flag_test_only)
    {
        return write_needed;
    }

    // Ensure directory exists before writing
    int dir_result = EnsureDirectoryExists(flags);
    if (dir_result != 0)
    {
        return dir_result;
    }

    // Write the file
    int write_result = WriteToFile();
    if (write_result != write_success)
    {
        return write_result;
    }

    if (ttwx::is_found(m_additional_content))
    {
        return write_edited;
    }
    return write_success;
}

[[nodiscard]] auto FileCodeWriter::GetCommentLineToFind(GenLang language) -> std::string_view
{
    if (language == GEN_LANG_CPLUSPLUS)
    {
        return cpp_end_cmt_line;
    }
    if (language == GEN_LANG_PYTHON || language == GEN_LANG_RUBY || language == GEN_LANG_PERL)
    {
        return python_perl_ruby_end_cmt_line;
    }
    return {};
}

[[nodiscard]] auto FileCodeWriter::GetBlockLength(GenLang language) -> size_t
{
    return (language == GEN_LANG_CPLUSPLUS) ? 8 : 6;
}

[[nodiscard]] auto FileCodeWriter::GetCommentCharacter(GenLang language) -> std::string_view
{
    return (language == GEN_LANG_CPLUSPLUS) ? "//" : "#";
}

[[nodiscard]] auto FileCodeWriter::IsOldStyleFile() -> bool
{
    constexpr auto npos = std::string::npos;
    return m_org_file.size() > 3 && m_org_file[1].find("Code generated by wxUiEditor") != npos &&
           m_org_file[3].find(
               "DO NOT EDIT THIS FILE! Your changes will be lost if it is re-generated!") != npos;
}

[[nodiscard]] auto FileCodeWriter::FindAdditionalContentIndex() -> size_t
{
    // Search for the comment line in m_new_file first, ensuring both files match
    auto search_result =
        std::ranges::find_if(std::views::iota(size_t(0), m_new_file.size()),
                             [this](size_t line_index) -> bool
                             {
                                 if (line_index >= m_org_file.size())
                                 {
                                     return true;  // Trigger exit condition
                                 }
#if defined(_DEBUG)
                                 auto org_start = m_org_file[line_index];
                                 auto new_start = m_new_file[line_index];
#else
            // Optimize: compute find_nonspace once per line
            auto org_start = ttwx::find_nonspace(m_org_file[line_index]);
            auto new_start = ttwx::find_nonspace(m_new_file[line_index]);
#endif
                                 return org_start != new_start ||
                                        m_new_file[line_index].starts_with(m_comment_line_to_find);
                             });

    if (search_result != std::ranges::end(std::views::iota(size_t(0), m_new_file.size())))
    {
        size_t line_index = *search_result;
        if (line_index < m_org_file.size() &&
            m_new_file[line_index].starts_with(m_comment_line_to_find))
        {
            return line_index + m_block_length;
        }
        return (to_size_t) -1;
    }

    // Continue searching in the original file if not found yet
    auto org_search =
        std::ranges::find_if(std::views::iota(m_new_file.size(), m_org_file.size()),
                             [this](size_t line_index) -> bool
                             {
                                 return m_org_file[line_index].starts_with(m_comment_line_to_find);
                             });

    if (org_search != std::ranges::end(std::views::iota(m_new_file.size(), m_org_file.size())))
    {
        size_t line_index = *org_search;
        return line_index + m_block_length;
    }

    return (to_size_t) -1;
}

void FileCodeWriter::AppendCppEndBlock()
{
    if (m_flags & code::flag_add_closing_brace)
    {
        ttwx::StringVector lines;
        lines.ReadString(end_cpp_block);
        for (auto& iter: lines)
        {
            if (iter.starts_with("// clang-format on"))
            {
                --m_block_length;
            }
            else
            {
                m_buffer += iter;
                m_buffer += "\n";
            }
        }
        if (!m_file_exists)
        {
            m_buffer += "  // clang-format on\n};\n";
        }
    }
    else
    {
        m_buffer += end_cpp_block;
    }
}

void FileCodeWriter::AppendPerlEndBlock()
{
    m_buffer += end_python_perl_ruby_block;
    if (!m_file_exists && m_node)
    {
        m_buffer += "\n1;  # " + m_node->get_NodeName();
    }
}

void FileCodeWriter::AppendPythonEndBlock()
{
    m_buffer += end_python_perl_ruby_block;
}

void FileCodeWriter::AppendRubyEndBlock()
{
    m_buffer += end_python_perl_ruby_block;
    if (m_node && !m_node->is_Gen(GenEnum::gen_Images) && !m_node->is_Gen(GenEnum::gen_Data))
    {
        // If the file doesn't exist, or it is missing any user content, append psuedo user content
        // that adds the "end" statement for the class.
        if (!m_file_exists || !ttwx::is_found(m_additional_content))
        {
            Code code(m_node, GEN_LANG_RUBY);
            code.Eol().Str("end  # end of ").Str(m_node->get_NodeName()).Str(" class").Eol();
            m_buffer += code;
        }
    }
}

void FileCodeWriter::AppendEndOfFileBlock()
{
    switch (m_language)
    {
        case GEN_LANG_CPLUSPLUS:
            AppendCppEndBlock();
            break;
        case GEN_LANG_PERL:
            AppendPerlEndBlock();
            break;
        case GEN_LANG_PYTHON:
            AppendPythonEndBlock();
            break;
        case GEN_LANG_RUBY:
            AppendRubyEndBlock();
            break;
        default:
            break;
    }
}

void FileCodeWriter::AppendMissingCommentBlockWarning()
{
    const auto comment_char = GetCommentCharacter(m_language);

    m_buffer += "\n";
    m_buffer += comment_char;
    m_buffer += "\n";
    m_buffer += comment_char;
    m_buffer += " The original file was missing the comment block ending the generated code!\n";
    m_buffer += comment_char;
    m_buffer += "\n";
    m_buffer += comment_char;
    m_buffer += " The entire original file has been copied below this comment block.\n\n";

    for (const auto& line: m_org_file)
    {
        m_buffer += line;
        m_buffer += "\n";
    }
}

void FileCodeWriter::AppendUserContent()
{
    if (m_language == GEN_LANG_RUBY && m_node && m_org_file.size() == m_new_file.size() + 2 &&
        (!m_node->is_Gen(GenEnum::gen_Images) && !m_node->is_Gen(GenEnum::gen_Data)))
    {
        // Ruby requires an 'end' statement for the class. We can't put it before the final comment
        // block, because then the user can add content to the class. So we we create our own user
        // content consisting of the the required end. The user can then extend the class by
        // inserting code after the final comment block but before the end statment.
        Code code(m_node, GEN_LANG_RUBY);
        code.Str("end  # end of ").Str(m_node->get_NodeName()).Str(" class");
        if (m_org_file[m_additional_content].empty() &&
            m_org_file[m_additional_content + 1] == code)
        {
            // The only thing added was our own end statement, so nothing else to append
            m_additional_content = write_current;
            return;
        }
    }

    for (size_t idx = m_additional_content; idx < m_org_file.size(); ++idx)
    {
        m_new_file.emplace_back(m_org_file[idx]);
    }
}

[[nodiscard]] auto FileCodeWriter::ReadOriginalFile(bool is_comparing) -> int
{
    m_org_file.clear();
    if (is_comparing)
    {
        wxFileName org_filename(m_filename);
        wxString name = org_filename.GetName();
        name.Replace("~wxue_", "");
        org_filename.SetName(name);
        if (!m_org_file.ReadFile(org_filename))
        {
            return write_cant_read;
        }
    }
    else if (!m_org_file.ReadFile(m_filename))
    {
        return write_cant_read;
    }
    return 0;
}

[[nodiscard]] auto FileCodeWriter::EnsureDirectoryExists(int flags) -> int
{
    wxFileName dir(m_filename);
    dir.ClearExt();
    dir.RemoveLastDir();

    if ((!dir.GetFullPath().empty() && dir.DirExists()) ||
        wxGetApp().AskedAboutMissingDir(dir.GetFullPath().ToStdString()))
    {
        return 0;
    }

    if (wxGetApp().is_Generating() || (flags & code::flag_no_ui))
    {
        return write_no_folder;
    }

    std::string msg("The directory:\n    \"" + std::string(dir.GetFullPath().ToStdString()) +
                    "\"\ndoesn't exist. Would you like it to be created?");
    wxMessageDialog dlg(nullptr, wxString::FromUTF8(msg), "Generate Files",
                        wxICON_WARNING | wxYES_NO);
    if (dlg.ShowModal() == wxID_YES)
    {
        if (!wxFileName::Mkdir(dir.GetFullPath(), wxS_DIR_DEFAULT, wxPATH_MKDIR_FULL))
        {
            msg = "The directory:\n    \"" + std::string(dir.GetFullPath().ToStdString()) +
                  "\"\ncould not be created.";
            wxMessageDialog dlg_error(nullptr, wxString::FromUTF8(msg), "Generate Files",
                                      wxICON_ERROR | wxOK);
            dlg_error.ShowModal();
            return write_cant_create;
        }
    }
    else
    {
        wxGetApp().AddMissingDir(dir.GetFullPath().ToStdString());
    }
    return 0;
}

[[nodiscard]] auto FileCodeWriter::WriteToFile() -> int
{
    wxFile fileOut;
    if (!fileOut.Create(m_filename.GetFullPath(), true))
    {
        return write_cant_create;
    }

    if (fileOut.Write(m_buffer.c_str(), m_buffer.length()) != m_buffer.length())
    {
        return write_error;
    }
    return write_success;
}

void FileCodeWriter::ProcessExistingFile()
{
    if (IsOldStyleFile())
    {
        if (m_flags & flag_test_only)
        {
            m_additional_content = write_needed;
        }
        return;
    }

    std::string_view look_for = GetCommentLineToFind(m_language);

    // Check if look_for exists in m_org_file
    auto found = std::ranges::find_if(m_org_file,
                                      [look_for](std::string_view line)
                                      {
                                          return line.starts_with(look_for);
                                      });

    if (found != m_org_file.end())
    {
        if (ttwx::is_found(m_additional_content))
        {
            // Ruby has to have an 'end' statement for the class. If there's nothing after the final
            // comment block, then we need to add it.
            if (m_language == GEN_LANG_RUBY && m_node && !m_node->is_Gen(GenEnum::gen_Images) &&
                !m_node->is_Gen(GenEnum::gen_Data))
            {
                // If the file is Ruby code, and there is no actual additional content
                // then add the "end" statement for the class.
                if (m_new_file.size() == m_additional_content)
                {
                    Code code(m_node, GEN_LANG_RUBY);
                    code.Eol()
                        .Str("end  # end of ")
                        .Str(m_node->get_NodeName())
                        .Str(" class")
                        .Eol();
                    m_buffer += code;
                    m_additional_content = write_needed;
                    return;
                }
            }

            // Normally we get here and just add whatever the user added after the final comment
            // block.
            AppendUserContent();
        }
    }
    else
    {
        // This means the final comment block is missing. We want to preserve all user content, but
        // we don't know what is user and what is ours, so we just copy it all. Presumably this will
        // be a rare occurrence unless AI decides to remove it...
        AppendMissingCommentBlockWarning();
    }

    // Check if files are identical (no changes needed)
    if (m_new_file.size() == m_org_file.size())
    {
        bool all_match = true;
        for (size_t i = 0; i < m_new_file.size(); ++i)
        {
            if (ttwx::find_nonspace(m_org_file[i]) != ttwx::find_nonspace(m_new_file[i]))
            {
                all_match = false;
                break;
            }
        }
        if (all_match)
        {
            m_additional_content = write_current;
            return;
        }
    }
}
