/////////////////////////////////////////////////////////////////////////////
// Purpose:   Generate Python code files
// Author:    Ralph Walden
// Copyright: Copyright (c) 2022-2025 KeyWorks Software (Ralph Walden)
// License:   Apache License -- see ../../LICENSE
/////////////////////////////////////////////////////////////////////////////

#include <algorithm>
#include <array>
#include <set>
#include <thread>

#include <wx/artprov.h>

#include "gen_python.h"
#include "gen_script_common.h"  // Common functions for generating Script Languages

#include "base_generator.h"   // BaseGenerator -- Base widget generator class
#include "code.h"             // Code -- Helper class for generating code
#include "comment_blocks.h"   // Shared generated comment blocks
#include "common_strings.h"   // Common strings used in code generation
#include "file_codewriter.h"  // FileCodeWriter -- Classs to write code to disk
#include "gen_common.h"       // Common component functions
#include "gen_timer.h"        // TimerGenerator class
#include "image_gen.h"        // Functions for generating embedded images
#include "image_handler.h"    // ImageHandler class
#include "node.h"             // Node class
#include "project_handler.h"  // ProjectHandler class
#include "tt_view_vector.h"   // tt_view_vector -- Read/Write line-oriented strings/files
#include "utils.h"            // Miscellaneous utilities
#include "write_code.h"       // Write code to Scintilla or file

#include "../customprops/eventhandler_dlg.h"  // EventHandlerDlg static functions

using namespace code;
using namespace GenEnum;

namespace
{

    void GatherImportModules(std::set<std::string>& imports, Node* node)
    {
        if (auto* gen = node->get_Generator(); gen)
        {
            gen->GetPythonImports(node, imports);
        }
        for (auto& child: node->get_ChildNodePtrs())
        {
            GatherImportModules(imports, child.get());
        }
    }

}  // anonymous namespace

PythonCodeGenerator::PythonCodeGenerator(Node* form_node) :
    BaseCodeGenerator(GEN_LANG_PYTHON, form_node)
{
}

auto PythonCodeGenerator::InitializeThreads(std::set<std::string>& img_include_set)
    -> std::tuple<std::thread, std::thread>
{
    auto thrd_get_events = std::thread(&PythonCodeGenerator::CollectEventHandlers, this,
                                       m_form_node, std::ref(m_events));
    auto thrd_collect_img_headers = std::thread(&PythonCodeGenerator::CollectImageHeaders, this,
                                                m_form_node, std::ref(img_include_set));

    return { std::move(thrd_get_events), std::move(thrd_collect_img_headers) };
}

auto PythonCodeGenerator::WriteSourceHeader() -> void
{
    if (m_panel_type == PANEL_PAGE::NOT_PANEL)
    {
        m_source->writeLine(txt_PythonCmtBlock);
        // Python style guidelines want a module document string
        m_source->writeLine("\"\"\"" + m_form_node->as_string(prop_class_name) +
                            " class generated by wxUiEditor.\"\"\"");
        m_source->writeLine();
    }

    if (Project.HasValue(prop_python_project_preamble))
    {
        WritePropSourceCode(Project.get_ProjectNode(), prop_python_project_preamble);
    }

    if (!m_form_node->is_Gen(gen_Images))
    {
        m_source->writeLine("import wx\n");
    }
}

auto PythonCodeGenerator::WriteImports(std::set<std::string>& imports) -> void
{
    GatherImportModules(imports, m_form_node);

    for (const auto& import: imports)
    {
        m_source->writeLine(import);
        if (m_header)
        {
            m_header->writeLine(import);
        }
    }
}

auto PythonCodeGenerator::WriteImportList() -> void
{
    if (m_form_node->HasValue(prop_python_import_list))
    {
        tt_string_vector list;
        list.SetString(m_form_node->as_string(prop_python_import_list));
        for (auto& iter: list)
        {
            if (!iter.starts_with("import "))
            {
                iter.remove_extension();
                m_source->writeLine(tt_string("import ") << iter);
            }
            else
            {
                m_source->writeLine(iter);
            }
        }
        if (list.size())
        {
            m_source->writeLine();
        }
    }
}

auto PythonCodeGenerator::WriteIDConstants() -> void
{
    m_set_enum_ids.clear();
    m_set_const_ids.clear();
    BaseCodeGenerator::CollectIDs(m_form_node, m_set_enum_ids, m_set_const_ids);

    // set to highest wx
    auto id_value = 1;
    for (const auto& iter: m_set_enum_ids)
    {
        if (!iter.starts_with("self."))
        {
            m_source->writeLine(tt_string() << iter << " = wx.ID_HIGHEST + " << id_value++);
        }
    }
    for (const auto& iter: m_set_const_ids)
    {
        if (!iter.starts_with("self."))
        {
            if (tt::contains(iter, " wx"))
            {
                wxString wx_id = iter;
                wx_id.Replace(" wx", " wx.", true);
                m_source->writeLine(wx_id.ToStdString());
            }
            else
            {
                m_source->writeLine(iter);
            }
        }
    }
}

auto PythonCodeGenerator::WriteInheritedClass() -> void
{
    // m_header is only set for display mode, not for file generation
    if (!m_header)
    {
        return;
    }

    m_header->writeLine(tt_string("# Sample inherited class from ")
                        << m_form_node->as_string(prop_class_name));
    m_header->writeLine();
    m_header->writeLine("import wx");

    m_header->writeLine();
    m_header->writeLine(tt_string("import ") << m_form_node->as_string(prop_python_file) << "\n");
    m_header->writeLine();

    tt_string inherit_name = m_form_node->as_string(prop_python_inherit_name);
    if (inherit_name.empty())
    {
        inherit_name += "inherit_" + m_form_node->as_string(prop_class_name);
    }
    if (inherit_name.size())
    {
        tt_string inherit("class ");
        inherit << inherit_name << "(";
        inherit << m_form_node->as_string(prop_python_file) << "."
                << m_form_node->as_string(prop_class_name) << "):";

        m_header->writeLine(inherit);
        m_header->Indent();
        m_header->writeLine("def __init__(self, parent):");
        m_header->writeLine("super().__init__(parent)");
        m_header->Unindent();
        m_header->writeLine();
    }
}

auto PythonCodeGenerator::WriteInsertCode() -> void
{
    if (m_form_node->HasValue(prop_python_insert))
    {
        tt_string convert(m_form_node->as_string(prop_python_insert));
        convert.Replace("@@", "\n", tt::REPLACE::all);
        tt_string_vector lines(convert, '\n', tt::TRIM::right);
        for (auto& line: lines)
        {
            m_source->doWrite(line);
            m_source->doWrite("\n");
        }
        m_source->doWrite("\n");
    }
}

auto PythonCodeGenerator::GenerateConstructionCode(Code& code) -> void
{
    auto* generator = m_form_node->get_NodeDeclaration()->get_Generator();
    code.clear();
    if (generator->ConstructionCode(code))
    {
        m_source->writeLine(code);
        m_source->writeLine();
        m_source->Indent();
        m_source->Indent();

        auto id_value = 1;
        for (const auto& iter: m_set_enum_ids)
        {
            if (iter.starts_with("self."))
            {
                m_source->writeLine(tt_string() << iter << " = wx.ID_HIGHEST + " << id_value++);
            }
        }
        if (id_value > 1)
        {
            // If at least one id was set, add a blank line
            m_source->writeLine();
        }
    }

    code.clear();
    if (generator->SettingsCode(code))
    {
        if (code.size())
        {
            m_source->writeLine(code);
            m_source->writeLine();
        }
    }

    if (m_form_node->get_PropPtr(prop_window_extra_style))
    {
        code.clear();
        code.GenWindowSettings();
        if (code.size())
        {
            m_source->writeLine(code);
        }
    }

    m_source->SetLastLineBlank();
    for (const auto& child: m_form_node->get_ChildNodePtrs())
    {
        if (child->is_Gen(gen_wxContextMenuEvent))
        {
            continue;
        }
        GenConstruction(child.get());
    }

    code.clear();
    if (generator->AfterChildrenCode(code))
    {
        if (code.size())
        {
            m_source->writeLine();
            m_source->writeLine(code);
        }
    }
}

auto PythonCodeGenerator::GenerateEventHandlers(Code& code, std::thread& thrd_get_events) -> void
{
    // Timer code must be created before the events, otherwise the timer variable won't exist
    // when the event is created.
    code.clear();
    if (TimerGenerator::StartIfChildTimer(m_form_node, code))
    {
        m_source->writeLine(code);
        m_source->writeLine();
    }

    // Delay calling join() for as long as possible to increase the chance that the thread will
    // have already completed.
    thrd_get_events.join();
    if (m_events.size())
    {
        m_source->writeLine();
        m_source->writeLine("# Bind Event handlers");
        GenSrcEventBinding(m_form_node, m_events);
        m_source->ResetIndent();
        m_source->writeLine();
        m_source->Indent();
        GenUnhandledEvents(m_events);
    }
}

auto PythonCodeGenerator::WriteWizardComment(Code& code) -> void
{
    if (m_form_node->is_Gen(gen_wxWizard))
    {
        code.clear();
        code.Eol().Str("# Add the following below the comment block to add a simple");
        code.Eol().Str("# Run() function to launch the wizard").Eol().Str(python_triple_quote);
        code.Eol().Str("def Run(self):");
        code.Tab().Str("return self.RunWizard(self.GetPageAreaSizer().GetItem(0).GetWindow())");
        code.Eol().Str(python_triple_quote).Eol().Eol();
        m_source->writeLine(code);
    }
}

void PythonCodeGenerator::GenerateClass(GenLang language, PANEL_PAGE panel_type)
{
    m_language = language;
    m_panel_type = panel_type;
    ASSERT(m_language == GEN_LANG_PYTHON);
    Code code(m_form_node, m_language);

    m_embedded_images.clear();
    SetImagesForm();
    std::set<std::string> img_include_set;
    m_baseFullPath = MakePythonPath(m_form_node);

    // Start threads early to process in background
    auto [thrd_get_events, thrd_collect_img_headers] = InitializeThreads(img_include_set);

    // If the code files are being written to disk, then UpdateEmbedNodes() has already been called.
    if (panel_type != PANEL_PAGE::NOT_PANEL)
    {
        ProjectImages.UpdateEmbedNodes();
    }

    std::vector<Node*> forms;
    Project.CollectForms(forms);

    m_panel_type = panel_type;

    if (m_header)
    {
        m_header->Clear();
    }
    m_source->Clear();
    m_source->SetLastLineBlank();

    WriteSourceHeader();

    if (m_form_node->is_Gen(gen_Images))
    {
        thrd_get_events.join();
        ScriptCommon::JoinThreadSafely(thrd_collect_img_headers);

        GenerateImagesForm();
        return;
    }

    std::set<std::string> imports;
    WriteImports(imports);
    WriteImportList();
    WriteIDConstants();

    ScriptCommon::JoinThreadSafely(thrd_collect_img_headers);

    if (m_embedded_images.size())
    {
        WriteImageImportStatements(code);
    }

    m_source->writeLine();
    WriteInheritedClass();
    WriteInsertCode();
    GenerateConstructionCode(code);

    // TODO: [Randalphwa - 12-04-2022] Python supports persistence, though it's not as easy as it is
    // in C++. See
    // https://docs.wxpython.org/wx.lib.agw.persist.html?highlight=persist#module-wx.lib.agw.persist

    GenerateEventHandlers(code, thrd_get_events);
    WriteWizardComment(code);

    // Make certain indentation is reset after all construction code is written
    m_source->ResetIndent();
    if (m_header)
    {
        m_header->ResetIndent();
    }

    std::ranges::sort(
        m_embedded_images,
        [](const EmbeddedImage* image_a, const EmbeddedImage* image_b)
        {
            return (image_a->base_image().array_name.compare(image_b->base_image().array_name) < 0);
        });
}

void PythonCodeGenerator::GenerateImagesForm()
{
    if (m_embedded_images.empty() || !m_form_node->get_ChildCount())
    {
        return;
    }

    m_source->writeLine();
    m_source->writeLine("from wx.lib.embeddedimage import PyEmbeddedImage");

    Code code(m_form_node, GEN_LANG_PYTHON);

    for (const auto* iter_array: m_embedded_images)
    {
        if (iter_array->get_Form() != m_form_node)
        {
            continue;
        }

        if (iter_array->base_image().filename.size())
        {
            code.Eol().Str("# ").Str(iter_array->base_image().filename);
        }
        code.Eol().Str(iter_array->base_image().array_name);
        if (iter_array->base_image().type == wxBITMAP_TYPE_SVG)
        {
            code.Str(" = (");
        }
        else
        {
            code.Str(" = PyEmbeddedImage(");
        }

        m_source->writeLine(code);
        code.clear();
        constexpr std::uint32_t array_size_mask = 0xFFFFFFFF;
        auto encoded =
            base64_encode(iter_array->base_image().array_data.data(),
                          iter_array->base_image().array_size & array_size_mask, GEN_LANG_PYTHON);
        if (encoded.size())
        {
            encoded.back() += ")";
            m_source->writeLine(encoded);
        }
    }

    m_source->writeLine();
}

void PythonCodeGenerator::WriteImageImportStatements(Code& code)
{
    ASSERT_MSG(m_embedded_images.size(),
               "CheckMimeBase64Requirement() should only be called if there are embedded images");
    if (m_embedded_images.empty())
    {
        return;
    }
    m_source->writeLine();

    bool images_file_imported = false;
    bool svg_import_libs = false;
    WriteImagesFormImport(code, images_file_imported, svg_import_libs);

    bool blank_line_seen = WriteExternalImageImports(code);
    WriteEmbeddedImageImports(code, blank_line_seen);
}

auto PythonCodeGenerator::WriteImagesFormImport(Code& code, bool& images_file_imported,
                                                bool& svg_import_libs) -> void
{
    for (auto& iter: m_embedded_images)
    {
        if (iter->get_Form() == m_ImagesForm)
        {
            if (!images_file_imported)
            {
                tt_string import_name = iter->get_Form()->as_string(prop_python_file).filename();
                import_name.remove_extension();
                code.Str("import ").Str(import_name);
                m_source->writeLine(code);
                code.clear();
                images_file_imported = true;
            }
            if (iter->base_image().type == wxBITMAP_TYPE_SVG)
            {
                m_source->writeLine("import zlib");
                m_source->writeLine("import base64");
                svg_import_libs = true;
            }
        }
        else if (!svg_import_libs)
        {
            if (iter->base_image().type == wxBITMAP_TYPE_SVG)
            {
                m_source->writeLine("import zlib");
                m_source->writeLine("import base64");
                svg_import_libs = true;
            }
        }
    }
}

auto PythonCodeGenerator::WriteExternalImageImports(Code& code) -> bool
{
    bool blank_line_seen = false;
    for (auto& iter: m_embedded_images)
    {
        if (iter->get_Form() != m_ImagesForm && iter->get_Form() != m_form_node)
        {
            if (!blank_line_seen)
            {
                m_source->writeLine();
                blank_line_seen = true;
            }
            if (iter->get_Form()->as_string(prop_python_file).filename().empty())
            {
                code.AddComment(tt_string("No filename specified for ")
                                    << iter->get_Form()->get_FormName() << " which contains "
                                    << iter->base_image().array_name,
                                true);
                code += "# ";
            }
            code.Str("from ")
                .Str(iter->get_Form()->as_string(prop_python_file).filename())
                .Str(" import ");
            code.Str(iter->base_image().array_name);
            m_source->writeLine(code);
            code.clear();
        }
    }
    return blank_line_seen;
}

auto PythonCodeGenerator::WriteEmbeddedImageImports(Code& code, bool blank_line_seen) -> void
{
    for (auto& iter: m_embedded_images)
    {
        // Only write the images that aren't declared in any gen_Images List. Note that
        // this *WILL* result in duplicate images being written to different forms.
        if (iter->get_Form() == m_form_node)
        {
            // This will be true if an image was declared in a different form
            if (blank_line_seen)
            {
                m_source->writeLine();
            }
            m_source->writeLine("from wx.lib.embeddedimage import PyEmbeddedImage");
            WriteImageConstruction(code);
            break;
        }
    }
}

auto PythonCodeGenerator::CollectExistingEventHandlers(std::unordered_set<std::string>& code_lines)
    -> bool
{
    return ScriptCommon::CollectExistingEventHandlers(m_form_node, GEN_LANG_PYTHON, m_panel_type,
                                                      code_lines, "def ");
}

auto PythonCodeGenerator::GenerateEventHandlerComment(bool found_user_handlers, Code& code) -> void
{
    ScriptCommon::GenerateEventHandlerComment(found_user_handlers, code, GEN_LANG_PYTHON);
}

auto PythonCodeGenerator::GenerateEventHandlerBody(NodeEvent* event, Code& code) -> void
{
#ifdef _DEBUG
    const auto& dbg_event_name = event->get_name();
    wxUnusedVar(dbg_event_name);
#endif  // _DEBUG
    ScriptCommon::GenerateEventHandlerBody(event, code, GEN_LANG_PYTHON);
}

auto PythonCodeGenerator::CheckIfAllEventsImplemented(
    EventVector& events, const std::unordered_set<std::string>& code_lines,
    bool found_user_handlers) -> bool
{
    if (!found_user_handlers)
    {
        return false;
    }

    for (auto& event: events)
    {
        auto python_handler = EventHandlerDlg::GetPythonValue(event->get_value());
        // Ignore lambda's
        if (python_handler.starts_with("[python:lambda]"))
        {
            continue;
        }

        tt_string set_code;
        // If the user doesn't use the `event` parameter, they may use '_' instead to indicate
        // an unused parameter.
        set_code << "def " << python_handler << "(self, _):";
        if (code_lines.contains(set_code))
        {
            continue;
        }
        set_code.clear();
        set_code << "def " << python_handler << "(self, event):";
        if (code_lines.contains(set_code))
        {
            continue;
        }

        // At least one event wasn't implemented
        return false;
    }
    return true;
}

auto PythonCodeGenerator::GenerateUndefinedHandlers(EventVector& events,
                                                    std::unordered_set<std::string>& code_lines,
                                                    Code& undefined_handlers) -> void
{
    for (auto& event: events)
    {
        auto python_handler = EventHandlerDlg::GetPythonValue(event->get_value());
        // Ignore lambda's
        if (python_handler.empty() || python_handler.starts_with("[python:lambda]"))
        {
            continue;
        }

        tt_string set_code;
        // If the user doesn't use the `event` parameter, they may use '_' instead to indicate
        // an unused parameter.
        set_code << "def " << python_handler << "(self, _):";
        if (code_lines.contains(set_code))
        {
            continue;
        }
        set_code.Replace("_)", "event)");
        if (code_lines.contains(set_code))
        {
            continue;
        }
        code_lines.emplace(set_code);

        undefined_handlers.Str(set_code).Eol();
        GenerateEventHandlerBody(event, undefined_handlers);
    }
}

auto PythonCodeGenerator::WriteEventHandlers(Code& code, Code& undefined_handlers,
                                             bool found_user_handlers,
                                             bool is_all_events_implemented) -> void
{
    if (m_header)
    {
        if (found_user_handlers && !is_all_events_implemented)
        {
            m_header->writeLine("# Unimplemented Event handler functions");
        }
        else
        {
            m_header->writeLine("# Event handler functions");
        }
        m_header->writeLine(undefined_handlers);
    }

    if (!is_all_events_implemented)
    {
        m_source->writeLine(code);
        code.Eol(eol_if_needed).Str(python_triple_quote).Eol().Eol();
        m_source->writeLine(code);
    }
}

void PythonCodeGenerator::GenUnhandledEvents(EventVector& events)
{
    ASSERT_MSG(events.size(), "GenUnhandledEvents() shouldn't be called if there are no events");
    if (events.empty())
    {
        return;
    }

    // Multiple events can be bound to the same function, so use a set to make sure we only generate
    // each function once.
    std::unordered_set<std::string> code_lines;

    Code code(m_form_node, GEN_LANG_PYTHON);
    auto sort_event_handlers = [](NodeEvent* event_a, NodeEvent* event_b)
    {
        return (EventHandlerDlg::GetPythonValue(event_a->get_value()) <
                EventHandlerDlg::GetPythonValue(event_b->get_value()));
    };

    // Sort events by function name
    std::sort(events.begin(), events.end(), sort_event_handlers);

    bool inherited_class = m_form_node->HasValue(prop_python_inherit_name);
    if (m_header)
    {
        if (!inherited_class)
        {
            m_header->Indent();
        }
        else
        {
            m_header->Unindent();
            m_header->writeLine();
        }
    }

    bool found_user_handlers = CollectExistingEventHandlers(code_lines);
    bool is_all_events_implemented =
        CheckIfAllEventsImplemented(events, code_lines, found_user_handlers);

    if (is_all_events_implemented)
    {
        // If the user has defined all the event handlers, then we don't need to output anything
        // else.
        return;
    }

    GenerateEventHandlerComment(found_user_handlers, code);
    m_source->writeLine(code);

    code.clear();
    Code undefined_handlers(m_form_node, GEN_LANG_PYTHON);
    GenerateUndefinedHandlers(events, code_lines, undefined_handlers);

    WriteEventHandlers(code, undefined_handlers, found_user_handlers, is_all_events_implemented);

    if (m_header && !inherited_class)
    {
        m_header->Unindent();
    }
}

bool PythonBitmapList(Code& code, GenEnum::PropName prop)
{
    const auto& description = code.node()->as_string(prop);
    ASSERT_MSG(description.size(), "PythonBitmapList called with empty description");
    tt_view_vector parts(description, BMP_PROP_SEPARATOR, tt::TRIM::both);

    if (parts[IndexImage].empty() || parts[IndexType].contains("Art") ||
        parts[IndexType].contains("SVG"))
    {
        return false;
    }

    const auto* bundle = ProjectImages.GetPropertyImageBundle(description);

    constexpr size_t min_bitmap_bundle_size = 3;
    if (!bundle || bundle->lst_filenames.size() < min_bitmap_bundle_size)
    {
        return false;
    }

    bool is_xpm = (parts[IndexType].is_sameas("XPM"));
    auto path = MakePythonPath(code.node());

    code += "bitmaps = [ ";
    bool needs_comma = false;
    constexpr size_t bitmap_list_indent_level = 3;
    for (const auto& iter: bundle->lst_filenames)
    {
        if (needs_comma)
        {
            code.UpdateBreakAt();
            code.Comma(false).Eol().Tab(bitmap_list_indent_level);
        }

        bool is_embed_success = false;
        if (parts[IndexType].starts_with("Embed"))
        {
            if (auto* embed = ProjectImages.GetEmbeddedImage(iter); embed)
            {
                code.AddPythonImageName(embed);
                code += ".Bitmap";
                needs_comma = true;
                is_embed_success = true;
            }
        }

        if (!is_embed_success)
        {
            tt_string name(iter);
            name.make_absolute();
            name.make_relative(path);
            name.backslashestoforward();

            code.Str("wx.Bitmap(").QuotedString(name);
            if (is_xpm)
            {
                code.Comma().Str("wx.BITMAP_TYPE_XPM");
            }
            code += ")";
            needs_comma = true;
        }
    }
    code += " ]\n";
    code.UpdateBreakAt();

    return true;
}

// REVIEW: [Randalphwa - 12-11-2025]
// TODO this struct and auto btn_bmp_types are duplicated in gen_common.cpp. Why does Python need
// it's own version of GenBtnBimapCode()?
struct BTN_BMP_TYPES
{
    GenEnum::PropName prop_name;
    const char* function_name;
};

inline constexpr auto btn_bmp_types = std::to_array<BTN_BMP_TYPES>({
    { .prop_name = prop_bitmap, .function_name = "SetBitmap" },
    { .prop_name = prop_disabled_bmp, .function_name = "SetBitmapDisabled" },
    { .prop_name = prop_pressed_bmp, .function_name = "SetBitmapPressed" },
    { .prop_name = prop_focus_bmp, .function_name = "SetBitmapFocus" },
    { .prop_name = prop_current, .function_name = "SetBitmapCurrent" },
});

void PythonBtnBimapCode(Code& code, bool is_single)
{
    for (const auto& iter: btn_bmp_types)
    {
        code.Eol(eol_if_needed);
        if (code.HasValue(iter.prop_name))
        {
            code.Eol(eol_if_needed);
            if (PythonBitmapList(code, iter.prop_name))
            {
                code.Eol(eol_if_needed).NodeName().Function(iter.function_name) << '(';
                code += "wx.BitmapBundle.FromBitmaps(bitmaps)";
            }
            else
            {
                code.Eol(eol_if_needed).NodeName().Function(iter.function_name) << '(';
                code.Bundle(iter.prop_name);
            }
            code.EndFunction();
        }
        if (is_single)
        {
            // Means the caller only wants prop_bitmap
            break;
        }
    }
}

tt_string MakePythonPath(Node* node)
{
    return ScriptCommon::MakeScriptPath(node, GEN_LANG_PYTHON);
}
