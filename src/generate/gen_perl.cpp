/////////////////////////////////////////////////////////////////////////////
// Purpose:   Generate Perl code files
// Author:    Ralph Walden
// Copyright: Copyright (c) 2024-2025 KeyWorks Software (Ralph Walden)
// License:   Apache License -- see ../../LICENSE
/////////////////////////////////////////////////////////////////////////////

#include <set>
#include <thread>
#include <unordered_set>

#include <frozen/map.h>

#include "mainframe.h"

#include "base_generator.h"   // BaseGenerator -- Base widget generator class
#include "code.h"             // Code -- Helper class for generating code
#include "file_codewriter.h"  // FileCodeWriter -- Classs to write code to disk
#include "gen_base.h"         // BaseCodeGenerator -- Generate Src and Hdr files for Base Class
#include "gen_common.h"       // Common component functions
#include "gen_results.h"      // Code generation file writing functions
#include "image_gen.h"        // Functions for generating embedded images
#include "image_handler.h"    // ImageHandler class
#include "node.h"             // Node class
#include "project_handler.h"  // ProjectHandler class
#include "utils.h"            // Miscellaneous utilities
#include "write_code.h"       // Write code to Scintilla or file

#include "pugixml.hpp"

using namespace code;
using namespace GenEnum;

// clang-format off

inline constexpr const auto txt_PoundCmtBlock =
R"===(###############################################################################
# Code generated by wxUiEditor -- see https://github.com/KeyWorksRW/wxUiEditor/
#
# Do not edit any code above the "End of generated code" comment block.
# Any changes before that block will be lost if it is re-generated!
###############################################################################

)===";

inline constexpr const auto txt_perl_frame_app =
R"===(# Sample code for displaying your MainFrame window.
# Place this code after the closing comment block in your
# generated file. You can then call 'Perl filename.pl'
# where filename.pl is the name of your generated file.

package main;

my $app = Wx::SimpleApp->new;
my $frame = MainFrame->new(undef, -1, "wxPerl app");
$frame->Show;
$app->MainLoop;
)===";

// clang-format on

// extern constexpr auto map_perl_constants = frozen::make_map<GenEnum::PropName, std::string_view>;

// If the node contains the specified property, then the string contains all
// possible contants that could be used separated by spaces.
constexpr auto map_perl_constants = frozen::make_map<GenEnum::PropName, std::string_view>({

    { prop_bitmap, "wxNullBitmap" },

});

// Collects classes and constants that get output as "use Wx qw(...), use Wx::Class qw(...),
// etc."

// This will gather sorted collections that can bring in subsets of wxWidgets constants, classes,
// and packages. These get written out near the top of the generated code for each form.
class GatherPerlUsages
{
public:
    GatherPerlUsages(Node* form_node);

    std::set<std::string>& use_classes() { return m_use_classes; }
    std::set<std::string>& use_constants() { return m_use_constants; }
    std::set<std::string>& use_expands() { return m_use_expands; }
    std::set<std::string>& use_packages() { return m_use_packages; }

protected:
    void ParseNodes(Node* node);

private:
    std::set<std::string> m_art_ids;
    std::set<std::string> m_use_classes;
    std::set<std::string> m_use_constants;
    std::set<std::string> m_use_expands;  // for use Wx qw[:...];
    std::set<std::string> m_use_packages;
};

bool HasPerlMapConstant(std::string_view value)
{
    for (auto& iter: map_perl_constants)
    {
        if (tt::contains(iter.second, value))
            return true;
    }
    return false;
}

// This *MUST* be written without any indendation
const char* perl_begin_cmt_block = "=pod";

// This *MUST* be written without any indendation
const char* perl_end_cmt_block = "=cut";

void BaseCodeGenerator::GeneratePerlClass(PANEL_PAGE panel_type)
{
    Code code(m_form_node, GEN_LANG_PERL);

    m_embedded_images.clear();
    SetImagesForm();
    std::set<std::string> img_include_set;

    std::thread thrd_get_events(&BaseCodeGenerator::CollectEventHandlers, this, m_form_node, std::ref(m_events));
    std::thread thrd_collect_img_headers(&BaseCodeGenerator::CollectImageHeaders, this, m_form_node,
                                         std::ref(img_include_set));

    // If the code files are being written to disk, then UpdateEmbedNodes() has already been called.
    if (panel_type != NOT_PANEL)
    {
        ProjectImages.UpdateEmbedNodes();
    }

    std::vector<Node*> forms;
    Project.CollectForms(forms);

    m_panel_type = panel_type;

    m_header->Clear();
    m_source->Clear();

    if (m_form_node->isGen(gen_wxFrame))
    {
        code += txt_perl_frame_app;
        if (m_form_node->hasValue(prop_class_name))
        {
            tt_string class_name = m_form_node->as_string(prop_class_name);
            if (class_name.ends_with("Base"))
                class_name.erase(class_name.size() - 4);
            code.Replace("MainFrame", class_name);
        }
        m_header->writeLine(code);
        code.clear();
    }

    m_source->SetLastLineBlank();

#if !defined(_DEBUG)
    if (m_panel_type == NOT_PANEL)
#else
    if (m_panel_type != NOT_PANEL)
    {
        m_source->writeLine(
            "-- The following comment block is only displayed in a _DEBUG build, or when written to a file.\n\n");
    }
#endif  // _DEBUG
    {
        m_source->writeLine(txt_PoundCmtBlock);
    }

    code.Str("use Wx;").Eol();
    code.Str("package ").NodeName();
    if (code.ends_with("Base"))
        code.erase(code.size() - 4);
    code.Str(";").Eol();

    m_source->writeLine(code);
    code.clear();

    if (Project.hasValue(prop_perl_project_preamble))
    {
        WritePropSourceCode(Project.getProjectNode(), prop_perl_project_preamble);
    }

    m_source->writeLine();

    GatherPerlUsages usages(m_form_node);

    if (usages.use_classes().size())
    {
        m_source->writeLine();
        for (const auto& import: usages.use_classes())
        {
            m_source->writeLine(import);
        }
        m_source->writeLine();
    }

    if (usages.use_classes().size())
    {
        for (auto& iter: usages.use_packages())
        {
            m_source->writeLine(iter);
        }
        m_source->writeLine();
    }

    if (usages.use_expands().size())
    {
        for (auto& iter: usages.use_expands())
        {
            m_source->writeLine(iter);
        }
        m_source->writeLine();
    }

    if (usages.use_constants().size())
    {
        for (auto& iter: usages.use_constants())
        {
            m_source->writeLine(iter);
        }
        m_source->writeLine();
    }

    m_source->writeLine();
    m_source->writeLine("use strict;");

    if (m_form_node->isGen(gen_Images))
    {
        thrd_get_events.join();
        thrd_collect_img_headers.join();
        // GeneratePerlImagesForm();
        return;
    }

    m_set_enum_ids.clear();
    m_set_const_ids.clear();
    BaseCodeGenerator::CollectIDs(m_form_node, m_set_enum_ids, m_set_const_ids);

    int id_value = wxID_HIGHEST;
    for (auto& iter: m_set_enum_ids)
    {
        m_source->writeLine(tt_string() << '$' << iter << " = " << id_value++);
    }
    for (auto& iter: m_set_const_ids)
    {
        if (tt::contains(iter, " wx"))
        {
            tt_string id = '$' + iter;
            id.Replace(" wx", " wx.", true, tt::CASE::exact);
            m_source->writeLine(id);
        }
        else
        {
            m_source->writeLine('$' + iter);
        }
    }

    thrd_collect_img_headers.join();
    if (m_embedded_images.size())
    {
        m_source->writeLine();

        // TODO: [Randalphwa - 07-13-2023] Need to figure out how to handle images in wxPerl.
    }

    auto generator = m_form_node->getNodeDeclaration()->getGenerator();
    code.clear();
    if (generator->ConstructionCode(code))
    {
        m_source->writeLine(code);
        m_source->writeLine();
        m_source->Indent();
        m_source->Indent();

        id_value = wxID_HIGHEST;
        for (auto& iter: m_set_enum_ids)
        {
            m_source->writeLine(tt_string() << '@' << iter << id_value++);
        }

        if (id_value > 1)
        {
            // If at least one id was set, add a blank line
            m_source->writeLine();
        }
    }

    code.clear();
    m_source->ResetIndent(1);
    if (generator->SettingsCode(code))
    {
        if (code.size())
        {
            m_source->writeLine(code);
            m_source->writeLine();
        }
    }

    if (m_form_node->getPropPtr(prop_window_extra_style))
    {
        code.clear();
        code.GenWindowSettings();
        if (code.size())
        {
            m_source->writeLine(code);
        }
    }

    m_source->SetLastLineBlank();
    for (const auto& child: m_form_node->getChildNodePtrs())
    {
        if (child->isGen(gen_wxContextMenuEvent))
            continue;
        GenConstruction(child.get());
    }

    code.clear();
    if (generator->AfterChildrenCode(code))
    {
        if (code.size())
        {
            m_source->writeLine();
            m_source->writeLine(code);
        }
    }

    // TODO: [Randalphwa - 07-13-2023] Need to figure out if wxPerl supports persistence

    // Delay calling join() for as long as possible to increase the chance that the thread will
    // have already completed.
    thrd_get_events.join();
    if (m_events.size())
    {
        m_source->writeLine();
        m_source->writeLine("# Event handlers");
        GenSrcEventBinding(m_form_node, m_events);

        m_source->writeLine("\t# end Event handlers\n", indent::none);
        m_source->SetLastLineBlank();

        m_source->ResetIndent();
        m_source->writeLine();
        m_source->Indent();
        GenPerlEventHandlers(m_events);
    }
    else
    {
        m_source->ResetIndent();
    }

    if (m_form_node->isGen(gen_wxWizard))
    {
        code.clear();
        code.Eol().Str("# Add the following below the comment block to add a simple");
        code.Eol().Str("# Run() function to launch the wizard").Eol();
        m_source->writeLine(code);
    }

    // Make certain indentation is reset after all construction code is written
    m_source->ResetIndent();
    m_source->writeLine("\treturn $self;", indent::none);
    m_source->writeLine("}\n\n", indent::none);

    // Only add this when writing to disk. Otherwise, it needs to be added after
    // the comment block, and only if there is no user code after the comment
    // block. This is to ensure that the user can add event handlers that are
    // part of the package.
    if (panel_type != NOT_PANEL)
    {
        m_source->writeLine("1;", indent::none);
    }

    m_header->ResetIndent();

    // TODO: [Randalphwa - 07-13-2023] If we use embedded images, we need to write them out here.
#if 0
    std::sort(m_embedded_images.begin(), m_embedded_images.end(),
              [](const EmbeddedImage* a, const EmbeddedImage* b)
              {
                  return (a->array_name.compare(b->array_name) < 0);
              });
#endif
}

bool PerlBundleCode(Code& code, GenEnum::PropName prop)
{
    auto& description = code.node()->as_string(prop);
    if (description.empty())
    {
        code.Add("wxNullBitmap");
        return false;
    }

    tt_view_vector parts(description, BMP_PROP_SEPARATOR, tt::TRIM::both);

    if (parts.size() <= 1 || parts[IndexImage].empty())
    {
        code.Add("wxNullBitmap");
        return false;
    }

    return false;
}

tt_string MakePerlPath(Node* node)
{
    auto [path, has_base_file] = Project.GetOutputPath(node->getForm(), GEN_LANG_PERL);

    if (path.empty())
        path = "./";
    else if (has_base_file)
        path.remove_filename();
    return path;
}

GatherPerlUsages::GatherPerlUsages(Node* form_node)
{
    // This brings in all wxID_ constants, which is probably more than we need, but ensures they
    // are all available.
    m_use_expands.emplace("use Wx qw[:id];");

    ParseNodes(form_node);

    if (m_art_ids.size())
    {
        tt_string art_ids;
        for (auto& iter: m_art_ids)
        {
            if (art_ids.empty())
            {
                art_ids = "use Wx::ArtProvider qw(";
            }
            else
            {
                art_ids += ' ';
            }
            art_ids += iter;
            if (art_ids.size() > (Project.as_size_t(prop_perl_line_length) - 15))
            {
                art_ids += ");";
                m_use_packages.emplace(art_ids);
                art_ids.clear();
            }
        }
        if (art_ids.size())
        {
            art_ids += ");";
            m_use_packages.emplace(art_ids);
        }
    }
}

void GatherPerlUsages::ParseNodes(Node* node)
{
    if (node->isSizer())
    {
        m_use_expands.emplace("use Wx qw[:sizer];");

        // Now recurse through any children and their children
        for (auto& child: node->getChildNodePtrs())
        {
            ParseNodes(child.get());
        }
        return;
    }

    if (node->hasValue(prop_window_style) || node->hasValue(prop_window_extra_style) ||
        (node->hasValue(prop_variant) && node->as_string(prop_variant) != "normal"))
    {
        m_use_expands.emplace("use Wx qw[:window];");
    }

    if (node->hasValue(prop_bitmap) && node->as_string(prop_bitmap).contains("wxART_"))
    {
        m_use_packages.emplace("use Wx::ArtProvider qw[:artid :clientid];");
    }

    if (node->hasValue(prop_font))
    {
        m_use_expands.emplace("use Wx qw[:font];");
        FontProperty fontprop(node->getPropPtr(prop_font));
        if (fontprop.isDefGuiFont())
        {
            // If the font is a default GUI font, then we need to include the wxDefaultGuiFont constant.
            m_use_expands.emplace("use Wx qw[:systemsettings];");
        }
    }
    if (node->hasValue(prop_foreground_colour) || node->hasValue(prop_background_colour))
    {
        if (node->as_string(prop_foreground_colour).contains("wxSYS") ||
            node->as_string(prop_background_colour).contains("wxSYS"))
        {
            m_use_expands.emplace("use Wx qw[:systemsettings];");
        }
    }
    if (auto* gen = node->getGenerator(); gen)
    {
        std::set<std::string> imports;
        gen->GetImports(node, imports, GEN_LANG_PERL);
        for (auto& iter: imports)
        {
            if (iter.starts_with("use Wx qw[:"))
                m_use_expands.emplace(iter);
            else if (iter.starts_with("use Wx::"))
                m_use_packages.emplace(iter);
            else if (iter.starts_with("use Wx"))
                m_use_constants.emplace(iter);
            else
                m_use_classes.emplace(iter);
        }
        for (auto& iter: map_perl_constants)
        {
            if (node->hasProp(iter.first))
            {
                tt_string constants("use Wx qw(");
                constants += iter.second;
                constants += ");";
                m_use_constants.emplace(constants);
            }
        }
    }

    // Now recurse through any children and their children
    for (auto& child: node->getChildNodePtrs())
    {
        ParseNodes(child.get());
    }
}
